<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.0.19">
  <POU Name="FB_BCD" Id="{f3acc397-0efd-41fe-96b5-ff06c3870248}">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_BCD
VAR
	bolInitDone: BOOL;
	bolActivate: BOOL := TRUE;
	/// driver specific interface
	SIf: T_BCD;
	stStateMachine: T_BCD_StateMachine;
	stSubStateMachine: T_BCD_StateMachine;
	/// Create/release TCP/IP connection
	fbClientConnection: FB_ClientServerConnection;
	/// Send TCP/IP data
	fbSend: FB_SocketSend;
	/// Receive TCP/IP data
	fbReceive: FB_SocketReceive;
	/// Rx data buffer
	aRxData: ARRAY[0..300] OF BYTE;
	/// Tx data buffer
	aTxData: ARRAY[0..300] OF BYTE;
	intTxState: INT;
	bolExecuteSend: BOOL;
	/// counter for sended frames 
	udiNSend: UDINT;
	intRxState: INT;
	bolExecuteRead: BOOL;
	/// Count of received data bytes
	udiReceivedBytes: UDINT;
	strReceivedMessage: STRING(255);
END_VAR
VAR CONSTANT
	cBCD_SUB_Send: INT := 2000;
	cBCD_SUB_Wait: INT := 2001;
	cBCD_SUB_Read: INT := 2002;
	cBCD_SUB_CheckAnswer: INT := 2003;
	cBCD_SUB_GetData: INT := 2004;
	cBCD_SUB_Done: INT := 2005;
	cBCD_SUB_Error: INT := 2006;
	cTxIdle: USINT := 0;
	cTxBusy: USINT := 1;
	cRxIdle: USINT := 0;
	cRxBusy: USINT := 1;
	cRxConv: USINT := 2;
	cSTX: USINT := 16#2;
	cETX: USINT := 16#3;
	cCR: USINT := 16#D;
	cLF: USINT := 16#A;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*__________________________________________________________________________________________________
¦	
¦	Vistaprint Schweiz GmbH
¦	CH - 8401 Winterthur
¦
¦	www.vistaprint.ch - info@vistaprint.ch
¦___________________________________________________________________________________________________

Function desription:
TCP-IP driver for SICK barcode reader CLV632-0120
Note: This driver work as a TCP client.

History:
Version		Date			Author		Comment
---------------------------------------------------------------------------------------------------
0.00.1		18.12.2013		AVME/DSC	Start history
0.00.2		03.01.2014		AVME/DSC	Basic functionalities implemented and tested. Following commands are supported:
										CMD_CONNECT_SOCKET 	1002 		// Connect TCP socket
										CMD_CLOSE_SOCKET 	1004 		// Close TCP socket
										CMD_COM_TEST 		1006 		// Communication test 
										CMD_READ_BARCODE 	1014 		// Command enable the sensor gate for X-TIME ("duration" setting of sensor object trigger)
																		// Sensor try to detect a barcode.																					 							
		
___________________________________________________________________________________________________*)


IF (bolActivate) THEN // cyclic call enabled
	
	IF (bolInitDone=FALSE) THEN // first cycle -> init
		CtrlInit();	
		bolInitDone := TRUE;
	ELSE
		CycleStartDuty();
				
		StateMachine();
		
		CycleEndDuty();
	END_IF
	
END_IF;]]></ST>
    </Implementation>
    <Method Name="CtrlInit" Id="{21616382-407d-47b2-8fff-736f48d273dd}">
      <Declaration><![CDATA[METHOD PROTECTED CtrlInit : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// one time first cyclic call
// The socket is closed
stStateMachine.intStateNext := cBCD_STA_SocketClosed;]]></ST>
      </Implementation>
    </Method>
    <Method Name="StateMachine" Id="{5a5063a8-5316-4fe4-af63-164e61a40246}">
      <Declaration><![CDATA[METHOD PROTECTED StateMachine : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
// main statemachine
CASE stStateMachine.intState OF	
	cBCD_STA_WaitForJob:
   		THIS^.sta_WaitForJob();
	cBCD_STA_ConnectSocketBusy: 
        THIS^.sta_ConnectSocketBusy();	
	cBCD_STA_CloseSocketBusy: 
        THIS^.sta_CloseSocketBusy();		
	cBCD_STA_SocketClosed: 
        THIS^.sta_SocketClosed();	
	cBCD_STA_ComTestBusy:
	    THIS^.sta_ComTestBusy();
	cBCD_STA_ReadCodeBusy:
	    THIS^.sta_ReadCodeBusy();
    cBCD_STA_Error: 
        THIS^.sta_Error();
END_CASE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_Error" Id="{9c73cf3b-8cd6-4cc2-ad1c-2be88ddac496}">
      <Declaration><![CDATA[METHOD PROTECTED sta_Error : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (stStateMachine.intState<>stStateMachine.intStateLastCycle) THEN
		stStateMachine.intStateHistory := stStateMachine.intStateLastCycle;
		stStateMachine.intStateLastCycle := stStateMachine.intState;
		
		// Reset pending commands			
		bolExecuteSend:= FALSE;
		bolExecuteRead:= FALSE;
		
		// Reset Rx/Tx states
		intRxState:= cRxIdle;
		intTxState:= cTxIdle;
		
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (stStateMachine.intState=stStateMachine.intStateLastCycle) THEN
			
		// State Change Condition
		IF (SIf.stErr.bolErrAck = TRUE) THEN
			// Reset all active errors
			SIf.stErr.bolErrorActive := FALSE;
			SIf.stErr.bolSocketError := FALSE;
			SIf.stErr.bolSensorError := FALSE;
			SIf.stErr.udiErrorID := 0;
			SIf.stErr.bolErrAck := FALSE;
			// Needs reconnect for socket after an error!		
			stStateMachine.intStateNext := cBCD_STA_CloseSocketBusy;		
		END_IF
		
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (stStateMachine.intState<>stStateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_ConnectSocketBusy" Id="{7fb8021a-ee97-48f0-ae1d-460fd2d25634}">
      <Declaration><![CDATA[METHOD PROTECTED sta_ConnectSocketBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (stStateMachine.intState<>stStateMachine.intStateLastCycle) THEN
		stStateMachine.intStateHistory := stStateMachine.intStateLastCycle;
		stStateMachine.intStateLastCycle := stStateMachine.intState;
			
		// Initialize and connect socket
		fbClientConnection.nMode := 0; 			// not used
		fbClientConnection.sRemoteHost := SIf.stCfg.strSensorIPAdr;
		fbClientConnection.nRemotePort := SIf.stCfg.udiSensorPort;
		fbClientConnection.tReconnect := SIf.stPar.tTOConnection;
		fbClientConnection.bEnable:= TRUE;

	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (stStateMachine.intState=stStateMachine.intStateLastCycle) THEN
		
	
		// State Change Condition

		// Check about FUB error	
		IF (fbClientConnection.bError = TRUE) OR (fbClientConnection.nErrId <> 0) THEN
			SIf.stErr.bolErrorActive := TRUE;	
			SIf.stErr.bolSocketError := TRUE;
			SIf.stErr.udiErrorID := fbClientConnection.nErrId;
			stStateMachine.intStateNext := cBCD_STA_Error;
		END_IF
	
		// Wait for socket handle ID	
		IF (fbClientConnection.hSocket.handle <> 0) AND (fbClientConnection.eState = eSOCKET_CONNECTED) THEN
			stStateMachine.intStateNext := cBCD_STA_WaitForJob;
		END_IF

	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (stStateMachine.intState<>stStateMachine.intStateNext) THEN
		SIf.intCmd := cBCD_CMD_DONE;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_CloseSocketBusy" Id="{4a4f00a8-4ad6-48be-bfa5-046b0328d799}">
      <Declaration><![CDATA[METHOD PROTECTED sta_CloseSocketBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (stStateMachine.intState<>stStateMachine.intStateLastCycle) THEN
		stStateMachine.intStateHistory := stStateMachine.intStateLastCycle;
		stStateMachine.intStateLastCycle := stStateMachine.intState;
		
		// Close socket
		fbClientConnection.bEnable:= FALSE;

	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (stStateMachine.intState=stStateMachine.intStateLastCycle) THEN
		
	
		// State Change Condition

		// Check about FUB error	
		IF (fbClientConnection.bError = TRUE) OR (fbClientConnection.nErrId <> 0) THEN
			SIf.stErr.bolErrorActive := TRUE;	
			SIf.stErr.bolSocketError := TRUE;
			SIf.stErr.udiErrorID := fbClientConnection.nErrId;
			stStateMachine.intStateNext := cBCD_STA_Error;
		END_IF
	
		// Wait until socket is closed	
		IF (fbClientConnection.eState = eSOCKET_CLOSED) THEN
			stStateMachine.intStateNext := cBCD_STA_WaitForJob;
		ELSIF  (SIf.stErr.bolErrorActive= TRUE) THEN 
			stStateMachine.intStateNext := cBCD_STA_Error;		
		END_IF
	
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (stStateMachine.intState<>stStateMachine.intStateNext) THEN
		SIf.intCmd := cBCD_CMD_DONE;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_SocketClosed" Id="{fb8ffbef-b30f-410f-b97f-b36196101767}">
      <Declaration><![CDATA[METHOD PROTECTED sta_SocketClosed : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (stStateMachine.intState<>stStateMachine.intStateLastCycle) THEN
		stStateMachine.intStateLastCycle := stStateMachine.intState;
		;
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (stStateMachine.intState=stStateMachine.intStateLastCycle) THEN

		// State Change Condition
		IF (SIf.intCmd=cBCD_CMD_CONNECT_SOCKET) THEN
			stStateMachine.intStateNext := cBCD_STA_ConnectSocketBusy;
		END_IF
		
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (stStateMachine.intState<>stStateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="getSIf" Id="{7fb3ed53-7f15-4226-8ee0-34cc2a5ea6ca}">
      <Declaration><![CDATA[METHOD getSIf : POINTER TO T_BCD
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getSIf := ADR(SIf);]]></ST>
      </Implementation>
    </Method>
    <Method Name="getCmdState" Id="{f34f86a2-ef48-4127-850e-b41aa377cf21}">
      <Declaration><![CDATA[METHOD PROTECTED getCmdState : STRING
VAR_INPUT
	intCmdState: INT;
	bolState: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// get string cmd/state string information in runtime
IF (bolState=FALSE) THEN
	
// cmd's
	CASE intCmdState OF
		cBCD_CMD_DONE: 
			getCmdState := 'cBCD_CMD_DONE';
		cBCD_CMD_CONNECT_SOCKET: 
			getCmdState := 'cBCD_CMD_CONNECT_SOCKET';
		cBCD_CMD_CLOSE_SOCKET: 
			getCmdState := 'cBCD_CMD_CLOSE_SOCKET';
		cBCD_CMD_READ_BARCODE: 
			getCmdState := 'cBCD_CMD_READ_BARCODE';		
		cBCD_CMD_COM_TEST: 
			getCmdState := 'cBCD_CMD_COM_TEST';			
	END_CASE;
ELSE

// state's
	CASE intCmdState OF
		cBCD_STA_WaitForJob: 
			getCmdState := 'cBCD_STA_WaitForJob';
		cBCD_STA_ConnectSocketBusy: 
			getCmdState := 'cBCD_STA_ConnectSocketBusy';
		cBCD_STA_CloseSocketBusy: 
			getCmdState := 'cBCD_STA_CloseSocketBusy';
		cBCD_STA_SocketClosed: 
			getCmdState := 'cBCD_STA_SocketClosed';	
		cBCD_STA_ReadCodeBusy: 
			getCmdState := 'cBCD_STA_ReadCodeBusy';	
		cBCD_STA_ComTestBusy:
			getCmdState := 'cBCD_STA_ComTestBusy';	
		cBCD_STA_Error: 
			getCmdState := 'cBCD_STA_Error';
	END_CASE;
	
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="CycleEndDuty" Id="{a4b6435f-913d-4b04-9597-740f2fbd4604}">
      <Declaration><![CDATA[METHOD PROTECTED CycleEndDuty : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SIf.strState := THIS^.getCmdState(intCmdState:=stStateMachine.intState,bolState:=TRUE);

IF (stStateMachine.intState<>stStateMachine.intStateNext) THEN
	stStateMachine.intState := stStateMachine.intStateNext;  // set next state for next cycle
END_IF

(***************************************************************
        Function Block Calls
***************************************************************)

// Cyclic call of method "HandleTxData"
THIS^.HandleTxData();]]></ST>
      </Implementation>
    </Method>
    <Method Name="CycleStartDuty" Id="{69ddd546-64f1-401f-88b1-3698bf8f6e59}">
      <Declaration><![CDATA[METHOD PROTECTED CycleStartDuty : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// ----------------------------------------------------------------------------------
// cyclic actions outside of statemachine

// Simulation active
IF (SIf.stCfg.bolSimulation) THEN
	;
ELSE
	;
END_IF

// Cyclic call of the client connection
fbClientConnection();
// Cyclic call of method "HandleRxData"
THIS^.HandleRxData();

// Generate socket connected status info
IF (fbClientConnection.eState = eSOCKET_CONNECTED) THEN
	SIf.stStatus.bolSocketConnected:= TRUE;
ELSE
	SIf.stStatus.bolSocketConnected:= FALSE;	
	SIf.stStatus.bolComChecked:= FALSE;
END_IF

SIf.strCmd := THIS^.getCmdState(intCmdState:=SIf.intCmd,bolState:=FALSE);]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_WaitForJob" Id="{6c241500-b37d-4e30-808a-f7b2447e167e}">
      <Declaration><![CDATA[METHOD PROTECTED sta_WaitForJob : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (stStateMachine.intState<>stStateMachine.intStateLastCycle) THEN
		stStateMachine.intStateLastCycle := stStateMachine.intState;
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (stStateMachine.intState=stStateMachine.intStateLastCycle) THEN

		// State Change Condition
		IF (SIf.intCmd=cBCD_CMD_CONNECT_SOCKET) THEN						// Connect TCP socket
			stStateMachine.intStateNext := cBCD_STA_ConnectSocketBusy;
		ELSIF (SIf.intCmd=cBCD_CMD_CLOSE_SOCKET) THEN						// Close TCP socket
			stStateMachine.intStateNext := cBCD_STA_CloseSocketBusy;
		ELSIF (SIf.intCmd=cBCD_CMD_COM_TEST) THEN							// Communication test 
			stStateMachine.intStateNext := cBCD_STA_ComTestBusy;	
		ELSIF (SIf.intCmd=cBCD_CMD_READ_BARCODE) THEN						// Read bar code
			stStateMachine.intStateNext := cBCD_STA_ReadCodeBusy;				
		END_IF

				
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (stStateMachine.intState<>stStateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{304032db-0e4d-481d-9117-9c6dc5e70fb9}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	///if TRUE, the retain variables are initialized (warm start / cold start)
	bInitRetains: BOOL;
	///if TRUE, the instance afterwards gets moved into the copy code (online change)
	bInCopyCode: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Communication Settings
SIf.stCfg.strSensorIPAdr := '192.168.70.28';  //'192.168.0.10'; 
SIf.stCfg.udiSensorPort := 2111;

// Parameter
SIf.stPar.tTOConnection := T#10S;
SIf.stPar.tTOReceive := T#5S;
SIf.stPar.tTOSend := T#5S;]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_ComTestBusy" Id="{173d1586-2b76-4525-873b-926defcc0928}">
      <Declaration><![CDATA[METHOD PROTECTED sta_ComTestBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (stStateMachine.intState<>stStateMachine.intStateLastCycle) THEN
		stStateMachine.intStateHistory := stStateMachine.intStateLastCycle;
		stStateMachine.intStateLastCycle := stStateMachine.intState;

		// Clear data
		SIf.stData.stDevInfo.strComTestResult:='';
		SIf.stStatus.bolComChecked:=FALSE;
	
		// Init sub state machine
		stSubStateMachine.intState := cBCD_SUB_Send;
		stSubStateMachine.intStateNext := cBCD_SUB_Send;	
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (stStateMachine.intState=stStateMachine.intStateLastCycle) THEN
			
		// sub state machine for reading the bar code	
		CASE stSubStateMachine.intState OF

			cBCD_SUB_Send:
				// Check Tx state idle
				IF (intTxState = cTxIdle) THEN
					THIS^.PrepareSendMsg('sRI0'); // Call SOPAS command "sRI0"
					bolExecuteSend:= TRUE;
					stSubStateMachine.intState := cBCD_SUB_Wait;
				END_IF
		
			cBCD_SUB_Wait:
				// Wait until executed -> flag set back to false by method handle TxData
				IF (bolExecuteSend=FALSE)THEN
					stSubStateMachine.intState := cBCD_SUB_Read;
				END_IF
				
			cBCD_SUB_Read:
				// Check Rx state idle
				IF (intRxState = cRxIdle) THEN
					bolExecuteRead:= TRUE;
					stSubStateMachine.intState := cBCD_SUB_CheckAnswer;
				END_IF
			
			cBCD_SUB_CheckAnswer:
				// Wait until executed -> flag set back to false by method handle RxData
				IF (bolExecuteRead=FALSE)THEN				
					// Check about corresponding answer for the command						
					IF (TC2_STANDARD.FIND(strReceivedMessage,'sRA') <> 0) THEN
						SIf.stData.stDevInfo.strComTestResult:=strReceivedMessage;
						SIf.stStatus.bolComChecked:=TRUE;
					END_IF	
					stSubStateMachine.intState := cBCD_SUB_Done;
				END_IF
			
			cBCD_SUB_Done:
				; // job executed
			
		END_CASE
		
		 // job executed
		IF (stSubStateMachine.intState = cBCD_SUB_Done) THEN
			stStateMachine.intStateNext := cBCD_STA_WaitForJob;	
		END_IF
	
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (stStateMachine.intState<>stStateMachine.intStateNext) THEN
		SIf.intCmd := cBCD_CMD_DONE;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="PrepareSendMsg" Id="{8704fb91-cdb8-4a3c-9b4e-35959b301e59}">
      <Declaration><![CDATA[METHOD PRIVATE PrepareSendMsg
VAR_INPUT
	strMsg: STRING;
END_VAR
VAR
	intI: UINT;
	strCharacter: STRING(1);
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Clear send buffer
FOR intI:= 0 TO SIZEOF(aTxData)-1 DO
	aTxData[intI]:= 16#00;
END_FOR

// STX - start of telegramm
aTxData[0]:= cSTX;

// Loop over message string and convert to ASCII
FOR intI:= 1 TO INT_TO_UINT(LEN(strMsg)) DO
	// Get char
	strCharacter:= MID(strMsg,1,UINT_TO_INT(intI));
	// Convert to ASCII
	aTxData[intI]:= F_ToASC(strCharacter);
END_FOR

// ETX - end of telegramm
aTxData[intI]:= cETX;]]></ST>
      </Implementation>
    </Method>
    <Method Name="HandleTxData" Id="{c8dc6641-c363-4d59-be75-a424842ffbdf}">
      <Declaration><![CDATA[METHOD PRIVATE HandleTxData
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// HANDLE TX DATA
CASE intTxState OF
	
	// wait for send command (ready for send)
	cTxIdle:
		IF (bolExecuteSend) AND (fbClientConnection.eState = eSOCKET_CONNECTED)THEN									
			// send frame
			fbSend( bExecute := FALSE );
			fbSend(	sSrvNetID 	:= '',
					hSocket		:= fbClientConnection.hSocket,
					cbLen		:= SIZEOF(aTxData),
					pSrc		:= ADR(aTxData),					// pointer to the frame data
					bExecute	:= TRUE,
					tTimeout 	:= SIf.stPar.tTOSend);
	
			intTxState := cTxBusy;							
		END_IF
		
	// wait until send not busy
	cTxBusy:
		fbSend( bExecute := FALSE );
		IF NOT (fbSend.bBusy) THEN
			intTxState := cTxIdle;
			// Check about FUB error	
			IF (fbSend.bError = TRUE) THEN
				IF (SIf.stErr.bolErrorActive = FALSE) THEN
					SIf.stErr.bolErrorActive := TRUE;	
					SIf.stErr.udiErrorID := fbSend.nErrId;	
					// Try to close the socket. Needs reconnect for socket after an error!	
					stStateMachine.intStateNext := cBCD_STA_CloseSocketBusy;	
				END_IF				
			// no error
			ELSE
				udiNSend := udiNSend + 1; // increment the number of send frames
				bolExecuteSend:= FALSE;
			END_IF
		END_IF
		
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="HandleRxData" Id="{42c300b5-5700-4e5f-9132-9b31f8803b95}">
      <Declaration><![CDATA[METHOD PRIVATE HandleRxData
VAR
	uinI: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// GET/FETCH RX DATA
CASE intRxState OF
	
	// wait for read command
	cRxIdle:
		IF (bolExecuteRead=TRUE) AND (fbClientConnection.eState = eSOCKET_CONNECTED)THEN	

			// clear rx buffer
			FOR uinI:= 0 TO SIZEOF(aRxData)-1 DO
				aRxData[uinI]:= 16#00;
			END_FOR
			// Delete last message
			strReceivedMessage:= '';
			udiReceivedBytes := 0;
								
			// receive frame			
			fbReceive( bExecute := FALSE );
			fbReceive( 	sSrvNetId	:= '',
						hSocket		:= fbClientConnection.hSocket,
						cbLen		:= SIZEOF(aRxData),
						pDest		:= ADR(aRxData),
						bExecute	:= TRUE,
						tTimeout	:= SIf.stPar.tTOReceive);
			intRxState := cRxBusy;		
		END_IF
		
	// wait until receive not busy
	cRxBusy:
		fbReceive( bExecute := FALSE );
		IF NOT fbReceive.bBusy THEN
			IF NOT fbReceive.bError THEN
				IF (fbReceive.nRecBytes > 0) THEN (* some bytes received *)
					udiReceivedBytes := fbReceive.nRecBytes;
					intRxState := cRxConv; // convert received message
				ELSE
					// Try to read again
					intRxState := cRxIdle;
				END_IF	
			// Error	
			ELSE
				IF (SIf.stErr.bolErrorActive = FALSE) THEN
					SIf.stErr.bolErrorActive := TRUE;	
					SIf.stErr.udiErrorID := fbReceive.nErrId;	
					// Try to close the socket. Needs reconnect for socket after an error!	
					stStateMachine.intStateNext := cBCD_STA_CloseSocketBusy;	
				END_IF	
			END_IF			
		END_IF
			
	// convert received message to string
	cRxConv: 
		THIS^.PrepareReadMsg();
		bolExecuteRead:= FALSE; // Read done and data converted to string format
		intRxState := cRxIdle;
		
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="PrepareReadMsg" Id="{76f1d62e-8254-4fc9-a229-61ffcf5e7cf3}">
      <Declaration><![CDATA[METHOD PRIVATE PrepareReadMsg
VAR
	uinI: UINT;
	strCharacter: STRING(1);
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Delete last message
strReceivedMessage:= '';

// Loop over receive buffer
FOR uinI:= 0 TO SIZEOF(aRxData)-1 DO	
	// Start of text?
	IF (aRxData[uinI] = cSTX) THEN
		;
	// End of text?
	ELSIF (aRxData[uinI] = cETX) THEN
		EXIT;
	ELSE
		// Convert ASCII to string
		strCharacter:= F_ToCHR(aRxData[uinI]);
		strReceivedMessage:= CONCAT(strReceivedMessage,strCharacter);			
	END_IF
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_ReadCodeBusy" Id="{30c67254-be4e-43f8-8979-24e64c0ac693}">
      <Declaration><![CDATA[METHOD PROTECTED sta_ReadCodeBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (stStateMachine.intState<>stStateMachine.intStateLastCycle) THEN
		stStateMachine.intStateHistory := stStateMachine.intStateLastCycle;
		stStateMachine.intStateLastCycle := stStateMachine.intState;
		
		// Clear data
		SIf.stData.uliBarCode:=0;
		SIf.stData.strBarCode:='';
		SIf.stData.bolCodeReaded:= FALSE;
						
		// Init sub state machine
		stSubStateMachine.intState := cBCD_SUB_Send;
		stSubStateMachine.intStateNext := cBCD_SUB_Send;	
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (stStateMachine.intState=stStateMachine.intStateLastCycle) THEN
			
		// sub state machine for reading the bar code	
		CASE stSubStateMachine.intState OF

			cBCD_SUB_Send:
				// Check Tx state idle
				IF (intTxState = cTxIdle) THEN
					THIS^.PrepareSendMsg('sMN mTCgateon'); // Call SOPAS method "sMN mTCgateon"
					bolExecuteSend:= TRUE;
					stSubStateMachine.intState := cBCD_SUB_Wait;
				END_IF
		
			cBCD_SUB_Wait:
				// Wait until executed -> flag set back to false by method handle TxData
				IF (bolExecuteSend=FALSE)THEN
					stSubStateMachine.intState := cBCD_SUB_Read;
				END_IF
				
			cBCD_SUB_Read:
				// Check Rx state idle
				IF (intRxState = cRxIdle) THEN
					bolExecuteRead:= TRUE;
					stSubStateMachine.intState := cBCD_SUB_CheckAnswer;
				END_IF
			
			cBCD_SUB_CheckAnswer:
				// Wait until executed -> flag set back to false by method handle RxData
				IF (bolExecuteRead=FALSE)THEN				
					// Check about corresponding answer for the called method								
					IF (FC_StrComp(strReceivedMessage,'sAN mTCgateon 1') = 0) THEN			
						// Check Rx state idle
						IF (intRxState = cRxIdle) THEN
							bolExecuteRead:= TRUE;
							stSubStateMachine.intState := cBCD_SUB_GetData;
						END_IF
					END_IF	
				END_IF
			
			cBCD_SUB_GetData:
				// Wait until executed -> flag set back to false by method handle RxData
				IF (bolExecuteRead=FALSE)THEN
					
					// No barcode recognized after the end of the time window ("duration" setting of sensor object trigger), NoRead !
					IF ((TC2_STANDARD.FIND(strReceivedMessage,'OI=') <> 0) AND (TC2_STANDARD.FIND(strReceivedMessage,'*NoRead*') <> 0)) THEN			
						SIf.stData.strBarCode:='NoRead';
						stSubStateMachine.intState := cBCD_SUB_Done;
					END_IF
					
					// Barcode detected within the time window
					IF ((TC2_STANDARD.FIND(strReceivedMessage,'OI=') <> 0) AND NOT (TC2_STANDARD.FIND(strReceivedMessage,'*NoRead*') <> 0)) THEN
						// Prepare bar code data from received message
						THIS^.PrepareBarCodeData();
						stSubStateMachine.intState := cBCD_SUB_Done;
					END_IF
				END_IF
			
			cBCD_SUB_Done:
				; // job executed
			
		END_CASE
		
		 // job executed
		IF (stSubStateMachine.intState = cBCD_SUB_Done) THEN
			stStateMachine.intStateNext := cBCD_STA_WaitForJob;	
		END_IF
			
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (stStateMachine.intState<>stStateMachine.intStateNext) THEN
		SIf.intCmd := cBCD_CMD_DONE;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="PrepareBarCodeData" Id="{1fe7019f-4514-48da-a451-ed874f320318}">
      <Declaration><![CDATA[METHOD PRIVATE PrepareBarCodeData
VAR
	intI: INT;
	intStartIndex: INT;
	intStartIndexCode: INT;
	bASCIISign: BYTE;
	strCharacter: STRING(1);
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
// Note: Currently only the bar code is read out from the received message. "OI=" section in message.
// Other data sections like e.g. "TT=", "OTL=", "CC=" are not prepared.

// ----------------------------------------------------
// Get bar code and write result to structure "stData"
// ----------------------------------------------------
	
// Example of message: <stx> <CR><LF> TT=125ms OTL=0mm CC=1 OI=25<CR><LF>45376049874<CR><LF> .... and so on ...   <etx>
				 
// Get start index for bar code 'OI='
intStartIndex := TC2_STANDARD.FIND(strReceivedMessage,'OI=');

// Loop over received message to get the bar code
FOR intI:=intStartIndex TO LEN(strReceivedMessage)-intStartIndex DO	
	// Convert to ASCII to detect CR and LF
	bASCIISign:= F_ToASC(Mid(strReceivedMessage,1,intI));
	// The bar code number starts after LF					
	IF (bASCIISign = cLF) THEN
		// Save start index of the bar code
		intStartIndexCode:= intI + 1;
	END_IF
	// Read every single number of the bar code until the end "CR"
	IF ((intStartIndexCode <> 0) AND (intI >= intStartIndexCode)) THEN
		// As long as the end is not reached...(The bar code number ends with CR)	
		IF (bASCIISign <> cCR) THEN								
			// Write result to structure stData	
			strCharacter:= Mid(strReceivedMessage,1,intI);
			SIf.stData.strBarCode:= CONCAT(SIf.stData.strBarCode,strCharacter);	
			SIf.stData.uliBarCode:= STRING_TO_ULINT(SIf.stData.strBarCode);
			SIf.stData.bolCodeReaded:= TRUE;																	
		ELSE
			// end of bar code reached "CR" -> EXIT loop
			EXIT;
		END_IF
	END_IF
	
END_FOR]]></ST>
      </Implementation>
    </Method>
    <ObjectProperties>﻿<XmlArchive>
  <Data>
    <o xml:space="preserve" t="POUImageProperty">
      <n n="ImageData" />
      <v n="TransparencyColor">"White"</v>
      <v n="MakeTransparent">false</v>
    </o>
  </Data>
  <TypeList>
    <Type n="Boolean">System.Boolean</Type>
    <Type n="POUImageProperty">{bb741845-1ec5-4be9-bb0d-2cf7058af574}</Type>
    <Type n="String">System.String</Type>
  </TypeList>
</XmlArchive></ObjectProperties>
  </POU>
</TcPlcObject>