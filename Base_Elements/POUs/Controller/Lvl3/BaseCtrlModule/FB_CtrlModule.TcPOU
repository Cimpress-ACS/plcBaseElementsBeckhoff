<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.0.25">
  <POU Name="FB_CtrlModule" Id="{93bcbc09-e224-4f3b-9fe5-ea80da832953}">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_CtrlModule EXTENDS FB_CtrlBase
VAR_INPUT
	/// Inputs from global module for general supervision 
	/// Emergency circuit ok
	In_bolEmergencyOffOk: BOOL;
	/// No general error active, will be set to FALSE if there is an global error like e.g. over temperature in cabinet. 
	In_bolNoGeneralError: BOOL;
END_VAR
VAR
	/// Timeout supervision of Keep alive Toggle Bit
	udinTimeToggle_ms: UDINT;
	/// Specific interface struct
	SIf_MOD: T_Ctrl_SIf_MOD;
	uinGroupIndex: UINT;
	intCheckCounter: INT;
	uinMaxNrOfGroups: UINT := Base_Const.cMaxNrOfChilds;
	/// List of sequences
	aListOfSeq: ARRAY[0..Base_Const.cMaxNrOfChilds] OF T_Sequence;
	usiNumOfSeq: USINT := 0;
	usiNumOfValidPointerSeqChild: USINT := 0;
	/// [ms] List of waiting times for run sequence until the next group will execute
	/// If wait time is zero, next group will be directly executed after current group.  
	///	aListOfRunGrpWaitTime_ms: ARRAY[0..Base_Const.cMaxNrOfChilds] OF UDINT;
	usiNumOfRunGrpWaitTime: USINT := 0;
	/// [ms] List of waiting times for stop sequence until the next group will execute
	/// If wait time is zero, next group will be directly executed after current group. 
	///	aListOfStopGrpWaitTime_ms: ARRAY[0..Base_Const.cMaxNrOfChilds] OF UDINT;
	usiNumOfStopGrpWaitTime: USINT := 0;
	/// Array includes all registered childs of type IBuffer
	a_IBufferChildCtrl: ARRAY[0..Base_Const.cMaxNrOfChilds] OF IBuffer;
	a_IBufferFullChildCtrl: ARRAY[0..Base_Const.cMaxNrOfChilds] OF IBuffer;
	usiNumOfIBufferChild: USINT;
	usiNumOfIBufferFullChild: USINT;
	/// Counter
	ii: INT;
END_VAR
VAR CONSTANT
	/// sub States for run and stop sequences
	cSTA_SUB_INITIALIZED: INT := 500;
	cSTA_SUB_SEND_GROUP_CMD: INT := 502;
	cSTA_SUB_CHECK_GROUP_STATUS: INT := 504;
	cSTA_SUB_WAIT: INT := 506;
	cSTA_SUB_FINISHED: INT := 508;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*__________________________________________________________________________________________________
¦	
¦	Vistaprint Schweiz GmbH
¦	CH - 8401 Winterthur
¦
¦	www.vistaprint.ch - info@vistaprint.ch
¦___________________________________________________________________________________________________

Function desription:
Basic module controller implementation. This Controller should be the base father controller for all modules in shirt stream. 
e.g. used for ICL, ICB, Loading ...

Controller handle following basic functions:
--------------------------------------------
- Monitoring of common signals from cabinet
- Keep alive bit to line control
- General child handling RUN_busy, STOP_busy sequences and error handling

History:
Version		Date			Author		Comment
---------------------------------------------------------------------------------------------------
0.00.1		06.11.2013		AVM/DSC		Start history
0.00.2		14.11.2013		AVM/MRU		Changes in some methods
0.00.3		29.11.2013		AVM/MRU		Changes in IoInBridge
0.00.4		04.12.2013		AVM/MRU		Changes in Always - EOFFBusy
0.00.5		04.12.2013		AVM/MRU		Changes in Always - EOFFBusy at GeneralError
0.00.6		04.12.2013		AVM/MRU		Changes in Always - EOFFBusy if not in sta_EOFF 
0.00.7		05.12.2013		AVM/DSC		General revision of behaviour in case of emergency off (state EOFF) and general error (state ERROR).
										New handling for module specific interface.
0.00.8		06.12.2013		AVM/MRU		Add TSTOP in checkChildAlmClass
0.00.9		09.12.2013		AVM/DSC		BugFix in sub state "cSTA_SUB_CHECK_GROUP_STATUS" from run and stop sequence. Insert new "bolChecked" flag
						 				to detect if the sequence has been processed correctly.
0.00.10		11.12.2013		AVM/MRU		Clear pending command to prevent automatic recovery in sta_STOPBusy
0.00.11		13.01.2014		AVM/MRU		Bugzilla ID 03: BufferFull added
0.00.12		20.01.2014		AVM/MRU		EMO, general error reworked; AddRunGrp, AddStopGrp removed
										Timeout run/stop group added 
0.00.13		22.01.2014		AVM/MRU		Alternativ status for run sequence added
0.00.14		08.02.2014		VP/RE		Added bolStopReleaseHangers to CUR.

___________________________________________________________________________________________________*)


IF (me.bolActivate) AND (SIf_MOD.Cur<>0) AND (SIf_MOD.Cfg<>0) AND (SIf_MOD.Par<>0) AND (SIf_MOD.In<>0) THEN // cyclic call enabled
		FirstCycleInit();
		CycleStartDuty();
		Always();
		StateMachine();
		CycleEndDuty();
END_IF;
]]></ST>
    </Implementation>
    <Method Name="IoOutBridge" Id="{0547fd7b-a1af-4009-8ecb-2ef72dd56f49}">
      <Declaration><![CDATA[METHOD PROTECTED IoOutBridge : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// digitale and analoge inputs read from hardware or forcing
IF (CIf.SwCfg.bolSimulation = FALSE) THEN
	// check interlocks to prevent damages
	IF (CIf.Job.bolIlkOverwrite=FALSE) THEN
	;
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="getCmdState" Id="{12fc8a53-4b7a-4d57-b5d7-3d215ebc1d8b}">
      <Declaration><![CDATA[METHOD PROTECTED getCmdState : STRING
VAR_INPUT
	intCmdState: INT;
	bolState: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCmdState := SUPER^.getCmdState(intCmdState:=intCmdState,bolState:=bolState); // get global/base defined cmds/states
IF (getCmdState='') THEN // global not defined get local
	// get string cmd/state string information in runtime
	IF (bolState=FALSE) THEN
		// cmd's
	ELSE
	
	// cmd's
		CASE intCmdState OF	
			// SUB States
			cSTA_SUB_INITIALIZED:
				getCmdState := 'cSTA_SUB_INITIALIZED';
			cSTA_SUB_SEND_GROUP_CMD:
				getCmdState := 'cSTA_SUB_SEND_GROUP_CMD';
			cSTA_SUB_CHECK_GROUP_STATUS:
				getCmdState := 'cSTA_SUB_CHECK_GROUP_STATUS';
			cSTA_SUB_WAIT:
				getCmdState := 'cSTA_SUB_WAIT';
			cSTA_SUB_FINISHED:
				getCmdState := 'cSTA_SUB_FINISHED';
		END_CASE;
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Always" Id="{2b2066c4-4e8e-4805-ad8b-8de49b1882dd}">
      <Declaration><![CDATA[METHOD PROTECTED Always : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.Always();

// ---------------------------------------------------------------------------------
// Simulation
IF (CIf.SwCfg.bolSimulation) THEN
	SIf_Cur^.bolKeepAliveHost := NOT SIf_Cur^.bolKeepAlivePlc;
	// Simulate inputs from global module for general supervision (no physical inputs)
	SIf_In^.bolEmergencyOffOK.intern := TRUE;
	SIf_In^.bolNoGeneralError.intern := TRUE;
END_IF

// ----------------------------------------------------------------------------------
// cyclic actions outside of statemachine
IF (me.StateMachine.intState<>cSTA_SINGLE_ANSWER) THEN
	
	//-------------------------------------------------------------------------------
	// Monitoring of inputs from global module (no physical inputs)
	//-------------------------------------------------------------------------------
	
	// No general error
	IF ((SIf_In^.bolNoGeneralError.intern = FALSE) AND (me.StateMachine.intState <> cSTA_ERROR) AND (me.StateMachine.intState <> cSTA_ERRORQuit) 
		AND (me.StateMachine.intState <> cSTA_EOFF) AND (me.StateMachine.intState <> cSTA_EOFFBusy)) THEN
		me.StateMachine.intStateNext := cSTA_Error;		
	END_IF
	// As long as general error is not OK, set Alarm
	IF (SIf_In^.bolNoGeneralError.intern = FALSE) AND (me.StateMachine.intState = BASE_PLC.cSTA_ERROR) THEN
		// Set Alarm: SIf_MOD.Alm[4].strText := 'General error active'; 
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,4,0,ADR(SIf_MOD.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);		
	END_IF
	
	// Emergency Off
	IF ((SIf_In^.bolEmergencyOffOk.intern = FALSE) AND (me.StateMachine.intState <> cSTA_EOFF) AND (me.StateMachine.intState <> cSTA_EOFFBusy)
		AND (me.StateMachine.intState <> cSTA_ERROR) AND (me.StateMachine.intState <> cSTA_ERRORQuit)) THEN
		me.StateMachine.intStateNext := cSTA_EOFFBusy;				
	END_IF
	// As long as EMO is not OK, set Alarm
	IF (SIf_In^.bolEmergencyOffOk.intern = FALSE) AND ((me.StateMachine.intState = cSTA_EOFF) OR (me.StateMachine.intState = cSTA_EOFFBusy)) THEN
		// Set Alarm: SIf_MOD.Alm[3].strText := 'Emergency off active'; 
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,3,0,ADR(SIf_MOD.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);				
	END_IF
	
END_IF

//-------------------------------------------------------------------------------
// Keep Alive function to line controller with togglebit
//-------------------------------------------------------------------------------

// Communication to line control enabled
IF (SIf_Cfg^.bolComToLineControlEnabled = TRUE) THEN
	IF (SIf_Cur^.bolKeepAliveHost <> SIf_Cur^.bolKeepAlivePlc) THEN
		udinTimeToggle_ms := 0;
		SIf_Cur^.bolKeepAlivePlc := SIf_Cur^.bolKeepAliveHost;
	ELSE
		IF (udinTimeToggle_ms >= SIf_Par^.udiComTimeOutLineCtrl_ms) THEN
			// Set Alarm: SIf_MOD.Alm[2].strText := 'Communication error to line control'; 
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,2,UDINT_TO_DINT(udinTimeToggle_ms),ADR(SIf_MOD.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);	
			me.StateMachine.intStateNext := cSTA_Error;	
		END_IF
		udinTimeToggle_ms:= udinTimeToggle_ms + me.FUBInfo.udiSample_ms;
	END_IF
// Communication to line control disabled
ELSE
	SIf_Cur^.bolKeepAliveHost:= NOT SIf_Cur^.bolKeepAlivePlc;
END_IF

//-------------------------------------------------------------------------------
// Calculate the sum of all hangers in the system and the capacity of the system
//-------------------------------------------------------------------------------
IF (usiNumOfIBufferChild>0) THEN 
	SIf_Cur^.dinNumOfHangers:= 0;
	SIf_Cur^.dinMaxCapacity:= 0;
	FOR ii:= 0 TO (usiNumOfIBufferChild-1) DO
		SIf_Cur^.dinNumOfHangers:= SIf_Cur^.dinNumOfHangers + a_IBufferChildCtrl[ii].NumOfHangers;
		SIf_Cur^.dinMaxCapacity:= SIf_Cur^.dinMaxCapacity + a_IBufferChildCtrl[ii].MaxCapacity;
	END_FOR
END_IF

//-------------------------------------------------------------------------------
// Write BufferFull for LineControl into SIF
//-------------------------------------------------------------------------------
IF (usiNumOfIBufferFullChild>0) THEN 
	FOR ii:= 0 TO (usiNumOfIBufferFullChild-1) DO
		SIf_Cur^.a_bBufferIsFull[ii]:= a_IBufferFullChildCtrl[ii].BufferFull;
	END_FOR
END_IF


// ----------------------------------------------------------------------------------
// Conditions Always

// EOFF exist in FB_CtrlModule. Not overrule.
(*
// overrule error always from base -> no EOFF State!! in EOFF go to OFF
IF (me.StateMachine.intStateNext = cSTA_EOFFBusy) THEN
	IF (me.StateMachine.intState=cSTA_OFF) THEN
		me.StateMachine.intStateNext := cSTA_OFF;
	ELSE // stay in OFF
		me.StateMachine.intStateNext := cSTA_OFFBusy;
	END_IF
*)
IF (me.Alarm.eActivAlmClass=E_AlmClass.STOP) AND (me.StateMachine.intStateNext<>cSTA_Error)
		AND ((me.StateMachine.intState = cSTA_RUN) OR (me.StateMachine.intState = cSTA_RUNBusy))THEN
	// alarm evt STOP
	me.StateMachine.intStateNext := cSTA_STOPBusy;	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_RUN" Id="{2b57d42b-4072-44ef-bdb5-a7ee1dbac08c}">
      <Declaration><![CDATA[METHOD PROTECTED sta_RUN : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		;
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN

		// Simulation
		IF (CIf.SwCfg.bolSimulation) THEN
			;
		END_IF

		// State Change Condition	
		IF (me.intCmd=cCMD_STOP)  THEN
			me.StateMachine.intStateNext :=  cSTA_STOPBusy;	
		END_IF

	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_OFF" Id="{3750f796-76b8-4174-8fb8-c3e13e87b7c5}">
      <Declaration><![CDATA[METHOD PROTECTED sta_OFF : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		;		
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
				
		// State Change Condition
		IF (me.Alarm.eActivAlmClass<>E_AlmClass.EOFF) AND (me.Alarm.eActivAlmClass<>E_AlmClass.OFF) THEN
			IF (me.intCmd=cCMD_RUN) THEN 
				me.StateMachine.intStateNext := cSTA_RUNBusy;
			END_IF
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_EOFFBusy" Id="{43926500-8b3f-40d9-9943-c6ef440eaefb}">
      <Declaration><![CDATA[METHOD PROTECTED sta_EOFFBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// In case of an emergency, set all childs to off 
		// Set in cyclic action because of possible errors or manual/auto changes!
		SUPER^.SetAllChildCmd(BASE_PLC.cCMD_OFF);

		// check if all childs have reached the state
		IF CheckAllChildState(cSTA_OFF) THEN
			me.StateMachine.intStateNext := cSTA_EOFF;
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_STOP" Id="{44340596-81ec-4934-a2c3-05ad5626426e}">
      <Declaration><![CDATA[METHOD PROTECTED sta_STOP : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		;	
		// State Change Condition
		IF (me.Alarm.eActivAlmClass<>E_AlmClass.STOP) THEN
			IF (me.intCmd=cCMD_RUN) THEN
				me.StateMachine.intStateNext :=  cSTA_RUNBusy;
			END_IF
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_RUNBusy" Id="{459b0430-9f25-4ebc-ba23-68dcaa75419d}">
      <Declaration><![CDATA[METHOD PROTECTED sta_RUNBusy : BOOL
VAR
	ii: INT;
	bolFurtherGrpExist: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		// Init sub state machine
		me.SubStateMachine.intState := cSTA_SUB_INITIALIZED; 
		me.SubStateMachine.intStateNext := cSTA_SUB_INITIALIZED;
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN

		// Simulation
		IF (CIf.SwCfg.bolSimulation) THEN
			;
		END_IF
	
		// Start Cycle with substates	
		//--------------------------------------------------------------------------------------
		// sub state machine for sequence
		CASE me.SubStateMachine.intState OF
			//--------------------------------------------------------------------------------------
			cSTA_SUB_INITIALIZED:
			
				// Loop over all registered childs
				FOR ii:=0 TO usiNumOfSeq-1 BY 1 DO
					// Clear checked flag		
					aListOfSeq[ii].bolChecked:= FALSE;
				END_FOR
				uinGroupIndex:= 1;
				me.SubStateMachine.intStateNext := cSTA_SUB_SEND_GROUP_CMD;
				
			cSTA_SUB_SEND_GROUP_CMD:
				
				intCheckCounter:= 0;
				// Loop over all registered childs
				FOR ii:=0 TO usiNumOfSeq-1 BY 1 DO
					// If child is associated for the current group index		
					IF (aListOfSeq[ii].uinGroupRun = uinGroupIndex) THEN
						// Send defined command
						aListOfSeq[ii].pCIF^.Job.intACmd:= aListOfSeq[ii].intCmdSeqRun;
						intCheckCounter:= intCheckCounter + 1;
					END_IF			
				END_FOR
				// Change state
				me.SubStateMachine.intStateNext := cSTA_SUB_CHECK_GROUP_STATUS;
			
			
			cSTA_SUB_CHECK_GROUP_STATUS:
	
				// Loop over all registered childs
				FOR ii:=0 TO usiNumOfSeq-1 BY 1 DO
					// If child is associated for the current group index		
					IF (aListOfSeq[ii].uinGroupRun = uinGroupIndex) THEN
						// Check defined status and if child not already checked
						IF (((aListOfSeq[ii].pCIF^.Job.intState = aListOfSeq[ii].intStatusSeqRun) OR 
						(aListOfSeq[ii].pCIF^.Job.intState = aListOfSeq[ii].intStatusSeqRun2)) AND (aListOfSeq[ii].bolChecked = FALSE)) THEN
							aListOfSeq[ii].bolChecked:= TRUE;
							intCheckCounter:= intCheckCounter - 1;
						END_IF				
					END_IF			
				END_FOR
				
				// All childs in group has the right state
				IF (intCheckCounter <= 0) THEN		
					bolFurtherGrpExist:= FALSE;
					// Check if a further group exist!	
					FOR ii:=0 TO usiNumOfSeq-1 BY 1 DO	
						IF (aListOfSeq[ii].uinGroupRun > uinGroupIndex) THEN
							bolFurtherGrpExist:= TRUE;
							EXIT;
						END_IF			
					END_FOR
					// further group exist
					IF (bolFurtherGrpExist = TRUE) THEN
						IF (uinGroupIndex < uinMaxNrOfGroups) THEN			
							me.SubStateMachine.intStateNext := cSTA_SUB_WAIT;	
						END_IF
					ELSE
						me.SubStateMachine.intStateNext := cSTA_SUB_FINISHED;		
					END_IF
				END_IF

			cSTA_SUB_WAIT:
				
				IF (me.SubStateMachine.udiTimeInState_ms >= SIf_Par^.aListOfRunGrpWaitTime_ms[uinGroupIndex-1]) THEN
					// Inc. group index 
					uinGroupIndex:= uinGroupIndex + 1;	
					// Change state, send command for next group
					me.SubStateMachine.intStateNext := cSTA_SUB_SEND_GROUP_CMD;
				END_IF
			
			cSTA_SUB_FINISHED:
					;		
		END_CASE
		
		// Check time out error
		IF (SIf_MOD.Par^.udiTimeoutStarting_ms <> 0) AND (me.SubStateMachine.udiTimeInState_ms > (SIf_Par^.aListOfRunGrpWaitTime_ms[uinGroupIndex-1] + SIf_MOD.Par^.udiTimeoutStarting_ms)) THEN
			// SIf_MOD.Alm[5].strText := 'Timeout start group '; 
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,5,uinGroupIndex,ADR(SIf_MOD.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
		END_IF
		
		// State Change Condition
		IF (me.SubStateMachine.intState = cSTA_SUB_FINISHED) THEN
			me.StateMachine.intStateNext := cSTA_RUN;
		ELSIF (me.intCmd=cCMD_STOP) THEN
			me.StateMachine.intStateNext :=  cSTA_STOPBusy;	
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="CtrlInit" Id="{7a0ac12c-cff4-4e9e-8849-3ec85fb70fac}">
      <Declaration><![CDATA[METHOD PUBLIC CtrlInit : BOOL
VAR
	ii: INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.CtrlInit();

// Initialize all child controller
// Childs are listed in list of sequences
FOR ii:=0 TO usiNumOfSeq-1 BY 1 DO	
	aListOfSeq[ii].pCIF := THIS^.AddChild(aListOfSeq[ii].pChild^);
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_EOFF" Id="{7a7e2512-7c7d-4cf3-97d1-a6e983988ed7}">
      <Declaration><![CDATA[METHOD PROTECTED sta_EOFF : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;	
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN		
		
		// As long as the EMO is not reseted!
		IF NOT (SIf_In^.bolEmergencyOffOk.intern) THEN
			// Clear pending and new commands cyclic to prevent automatic recovery!
			CIf.Job.intACmd := BASE_PLC.cCMD_DONE;
			CIf.Job.intMCmd := BASE_PLC.cCMD_DONE;
		END_IF
	
		// State Change Condition
		IF (SIf_In^.bolEmergencyOffOk.intern) AND (me.Alarm.eActivAlmClass<>E_AlmClass.EOFF) AND (me.intCmd<>BASE_PLC.cCMD_EOFF) AND (me.intCmd<>BASE_PLC.cCMD_DONE) THEN
			me.StateMachine.intStateNext := cSTA_OFF;
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="checkValidPointer" Id="{7bc44136-2728-423e-a49d-d06c4040b9ac}">
      <Declaration><![CDATA[METHOD PROTECTED checkValidPointer : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (usiNumOfSeq = usiNumOfValidPointerSeqChild) AND (SIf_Cfg<>0) AND (SIf_Par<>0) AND (SIf_Cur<>0) AND (SIf_In<>0) THEN
	checkValidPointer:= TRUE;
ELSE
	// Invalid child pointer
	checkValidPointer:= FALSE;	
	// SIf.Alm[1].strText := 'Invalid pointer'; 
	pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,1,0,ADR(SIf_MOD.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);	
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddIBufferFullChilds" Id="{7bcb42ec-0ed0-4411-889a-451df2a9d0ed}">
      <Declaration><![CDATA[METHOD AddIBufferFullChilds
VAR_INPUT
	pFB_ChildTypeIBuffer: POINTER TO FB_IBuffer;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Method add childs with BufferFull information to the array
IF (usiNumOfIBufferFullChild <= (Base_Const.cMaxNrOfChilds-1)) THEN
	// Add child controller to list
	a_IBufferFullChildCtrl[usiNumOfIBufferFullChild] := pFB_ChildTypeIBuffer^;

	// Inc. number of IBufferFull childs
	usiNumOfIBufferFullChild:= usiNumOfIBufferFullChild+1;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Property Name="SIf_Cur" Id="{7c2240cf-17ab-4950-a777-bd60151c9f81}">
      <Declaration><![CDATA[PROPERTY SIf_Cur : POINTER TO T_Ctrl_SIf_MOD_Cur
]]></Declaration>
      <Set Name="Set" Id="{aec5c1a4-65f2-404c-8954-9252443dd039}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[SIf_MOD.Cur := SIf_Cur; ]]></ST>
        </Implementation>
      </Set>
      <Get Name="Get" Id="{b3d9c14f-7bba-46aa-8d01-2c4134f173fd}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[SIf_Cur:= SIf_MOD.Cur; ]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="IoInBridge" Id="{95c556ec-c88e-4a00-9f2f-5c4a543adc13}">
      <Declaration><![CDATA[METHOD PROTECTED IoInBridge : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Inputs from global module for general supervision (no physical inputs)
SIf_In^.bolEmergencyOffOk.map := THIS^.In_bolEmergencyOffOk;
SIf_In^.bolNoGeneralError.map := THIS^.In_bolNoGeneralError;

IF (CIf.SwCfg.bolSimulation = FALSE) THEN
	getInBol(CIf.Job.bolIoForce,ADR(SIf_In^.bolEmergencyOffOk));
	getInBol(CIf.Job.bolIoForce,ADR(SIf_In^.bolNoGeneralError));
ELSE
	//simulation of global IO
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddSeqChild" Id="{a0025313-0b7e-4dba-80b1-83806b0c4ebe}">
      <Declaration><![CDATA[METHOD AddSeqChild
VAR_INPUT
	stSequence: T_Sequence;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Method add a sequence to list
IF (usiNumOfSeq <= (Base_Const.cMaxNrOfChilds-1)) THEN
	aListOfSeq[usiNumOfSeq].pChild:= stSequence.pChild;
	aListOfSeq[usiNumOfSeq].uinGroupRun:= stSequence.uinGroupRun;
	aListOfSeq[usiNumOfSeq].uinGroupStop:= stSequence.uinGroupStop;
	aListOfSeq[usiNumOfSeq].intCmdSeqRun:= stSequence.intCmdSeqRun;
	aListOfSeq[usiNumOfSeq].intStatusSeqRun:= stSequence.intStatusSeqRun;
	aListOfSeq[usiNumOfSeq].intStatusSeqRun2:= stSequence.intStatusSeqRun2;
	aListOfSeq[usiNumOfSeq].intCmdSeqStop:= stSequence.intCmdSeqStop;
	aListOfSeq[usiNumOfSeq].intStatusSeqStop:= stSequence.intStatusSeqStop;
	// Inc. number of sequence
	usiNumOfSeq:= usiNumOfSeq+1;
	// Check if the pointer is valid
	IF (stSequence.pChild<>0) THEN
		usiNumOfValidPointerSeqChild:= usiNumOfValidPointerSeqChild+1;
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_STOPBusy" Id="{b4344b3d-9889-41b7-a53d-b3ca5d0bce3a}">
      <Declaration><![CDATA[METHOD PROTECTED sta_STOPBusy : BOOL
VAR
	ii: INT;
	bolFurtherGrpExist: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;	
		// Init sub state machine
		me.SubStateMachine.intState := cSTA_SUB_INITIALIZED; 
		me.SubStateMachine.intStateNext := cSTA_SUB_INITIALIZED;
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN

		// Simulation
		IF (CIf.SwCfg.bolSimulation) THEN
			;
		END_IF
		
		// Stop Cycle with substates	
		//--------------------------------------------------------------------------------------
		// sub state machine for sequence
		CASE me.SubStateMachine.intState OF
			//--------------------------------------------------------------------------------------
			cSTA_SUB_INITIALIZED:
			
				// Loop over all registered childs
				FOR ii:=0 TO usiNumOfSeq-1 BY 1 DO
					// Clear checked flag		
					aListOfSeq[ii].bolChecked:= FALSE;
				END_FOR
				uinGroupIndex:= 1;
				me.SubStateMachine.intStateNext := cSTA_SUB_SEND_GROUP_CMD;
				
			cSTA_SUB_SEND_GROUP_CMD:
				
				intCheckCounter:= 0;
				// Loop over all registered childs
				FOR ii:=0 TO usiNumOfSeq-1 BY 1 DO
					// If child is associated for the current group index		
					IF (aListOfSeq[ii].uinGroupStop = uinGroupIndex) THEN
						// Send defined command
						aListOfSeq[ii].pCIF^.Job.intACmd:= aListOfSeq[ii].intCmdSeqStop;
						intCheckCounter:= intCheckCounter + 1;
					END_IF			
				END_FOR
				// Change state
				me.SubStateMachine.intStateNext := cSTA_SUB_CHECK_GROUP_STATUS;
			
			
			cSTA_SUB_CHECK_GROUP_STATUS:
	
				// Loop over all registered childs
				FOR ii:=0 TO usiNumOfSeq-1 BY 1 DO
					// If child is associated for the current group index		
					IF (aListOfSeq[ii].uinGroupStop = uinGroupIndex) THEN
						// Check defined status and if child not already checked
						IF ((aListOfSeq[ii].pCIF^.Job.intState = aListOfSeq[ii].intStatusSeqStop) AND (aListOfSeq[ii].bolChecked = FALSE)) THEN
							aListOfSeq[ii].bolChecked:= TRUE;
							intCheckCounter:= intCheckCounter - 1;
						END_IF				
					END_IF			
				END_FOR
				
				// All childs in group has the right state
				IF (intCheckCounter <= 0) THEN		
					bolFurtherGrpExist:= FALSE;
					// Check if a further group exist!	
					FOR ii:=0 TO usiNumOfSeq-1 BY 1 DO	
						IF (aListOfSeq[ii].uinGroupStop > uinGroupIndex) THEN
							bolFurtherGrpExist:= TRUE;
							EXIT;
						END_IF			
					END_FOR
					// further group exist
					IF (bolFurtherGrpExist = TRUE) THEN
						IF (uinGroupIndex < uinMaxNrOfGroups) THEN			
							me.SubStateMachine.intStateNext := cSTA_SUB_WAIT;	
						END_IF
					ELSE
						me.SubStateMachine.intStateNext := cSTA_SUB_FINISHED;		
					END_IF
				END_IF

			cSTA_SUB_WAIT:
				
				IF (me.SubStateMachine.udiTimeInState_ms >= SIf_Par^.aListOfStopGrpWaitTime_ms[uinGroupIndex-1]) THEN
					// Inc. group index 
					uinGroupIndex:= uinGroupIndex + 1;	
					// Change state, send command for next group
					me.SubStateMachine.intStateNext := cSTA_SUB_SEND_GROUP_CMD;
				END_IF
			
			cSTA_SUB_FINISHED:
					;		
		END_CASE
		
		// Check time out error
		IF (SIf_MOD.Par^.udiTimeoutStopping_ms <> 0) AND (me.SubStateMachine.udiTimeInState_ms > (SIf_Par^.aListOfStopGrpWaitTime_ms[uinGroupIndex-1] + SIf_MOD.Par^.udiTimeoutStopping_ms)) THEN
			// SIf_MOD.Alm[6].strText := 'Timeout stop group '; 
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,6,uinGroupIndex,ADR(SIf_MOD.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
		END_IF
	
		// State Change Condition
		IF (me.SubStateMachine.intState = cSTA_SUB_FINISHED) THEN
			me.StateMachine.intStateNext := cSTA_STOP;
		ELSIF (me.intCmd=cCMD_RUN) THEN
			// State Change Condition
			IF (me.Alarm.eActivAlmClass<>E_AlmClass.STOP) THEN	
				me.StateMachine.intStateNext := cSTA_RUNBusy;	
			ELSE
				// Clear pending command to prevent automatic recovery!
				CIf.Job.intACmd:=cSTA_DONE;
			END_IF
		END_IF

	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Property Name="SIf_Par" Id="{b5260abe-a3fb-44c5-b308-7b394f794cb8}">
      <Declaration><![CDATA[PROPERTY SIf_Par : POINTER TO T_Ctrl_SIf_MOD_Par
]]></Declaration>
      <Set Name="Set" Id="{1ab8c3a9-59cf-4579-8f81-7e3553ee6144}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[SIf_MOD.Par := SIf_Par; ]]></ST>
        </Implementation>
      </Set>
      <Get Name="Get" Id="{fbeb4499-4f6e-48f1-8396-50521ce2dda3}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[SIf_Par:= SIf_MOD.Par; ]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="FB_init" Id="{ba738ca1-fd3b-440c-bfd2-18e244ab5591}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	///if TRUE, the retain variables are initialized (warm start / cold start)
	bInitRetains: BOOL;
	///if TRUE, the instance afterwards gets moved into the copy code (online change)
	bInCopyCode: BOOL;
END_VAR
VAR
	ii: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// to manually change in new FUB implementation!!!
// define valid commands for this controller
FOR ii:= 0 TO (SIZEOF(CIf.Job.aCmdList)/SIZEOF(CIf.Job.aCmdList[0])-1) BY 1 DO
	IF (CIf.Job.aCmdList[ii].intCmd=cCMD_INITIALIZED) THEN
		// found first empty array element
		EXIT;
	END_IF
END_FOR

CIf.Job.aCmdList[ii].intCmd := cCMD_RUN;
CIf.Job.aCmdList[ii].strName := 'Run'; 
CIf.Job.aCmdList[ii].bolAvailable := TRUE;
ii := ii +1;
CIf.Job.aCmdList[ii].intCmd := cCMD_STOP;
CIf.Job.aCmdList[ii].strName := 'Stop'; 
CIf.Job.aCmdList[ii].bolAvailable := TRUE;
ii := ii +1;

// set name of class/typ
CIf.Info.strType := 'FB_CtrlModule'; 

// set alarm class
SIf_MOD.Alm[1].eAlmClass := E_AlmClass.STOP;
SIf_MOD.Alm[1].strText := 'Invalid pointer';
SIf_MOD.Alm[2].eAlmClass := E_AlmClass.OFF;
SIf_MOD.Alm[2].strText := 'Communication error to line control'; 
SIf_MOD.Alm[3].eAlmClass := E_AlmClass.EOFF;
SIf_MOD.Alm[3].strText := 'Emergency off active'; 
SIf_MOD.Alm[4].eAlmClass := E_AlmClass.OFF;
SIf_MOD.Alm[4].strText := 'General error active'; 
SIf_MOD.Alm[5].eAlmClass := E_AlmClass.OFF;
SIf_MOD.Alm[5].strText := 'Timeout start group '; 
SIf_MOD.Alm[6].eAlmClass := E_AlmClass.OFF;
SIf_MOD.Alm[6].strText := 'Timeout stop group '; 

//*******************************************************************************
// initial values
//*******************************************************************************
udinTimeToggle_ms := 0;
// software configuration
CIf.SwCfg.bolExist := TRUE;
CIf.SwCfg.bolSimulation := FALSE;

// No initialization for cfg and par in this base module!
// Pointer address of the property is not defined at this time]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddIBufferChilds" Id="{bc49a60a-0556-4ce3-b7de-195ad0ea1e2e}">
      <Declaration><![CDATA[METHOD AddIBufferChilds
VAR_INPUT
	pFB_ChildTypeIBuffer: POINTER TO FB_IBuffer;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Method add childs with type of IBuffer to the array
IF (usiNumOfIBufferChild <= (Base_Const.cMaxNrOfChilds-1)) THEN
	// Add child controller to list
	a_IBufferChildCtrl[usiNumOfIBufferChild] := pFB_ChildTypeIBuffer^;
	// Inc. number of IBuffer childs
	usiNumOfIBufferChild:= usiNumOfIBufferChild+1;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="StateMachine" Id="{c244d7e5-c41f-489f-97da-65b69148df4b}">
      <Declaration><![CDATA[METHOD PROTECTED StateMachine : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.StateMachine();

// main statemachine of base controller
CASE me.StateMachine.intState OF
	cSTA_RUN: 
        THIS^.sta_RUN();
    cSTA_RUNBusy: 
        THIS^.sta_RUNBusy();
	cSTA_STOP: 
        THIS^.sta_STOP();
    cSTA_STOPBusy: 
        THIS^.sta_STOPBusy();
END_CASE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="checkChildAlmClass" Id="{cbf90ddf-9131-406d-b67f-19452c240e46}">
      <Declaration><![CDATA[METHOD checkChildAlmClass : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//------------------------------------------------------------------------------------------------------
// check child alarm classes
// set me alarm class active if at least one child has an EOFF
IF CheckAllChildAlmClass(E_AlmClass.EOFF) THEN
	CIf.Job.eMe_ActivAlmClass := E_AlmClass.EOFF;
	me.Alarm.bolfp := TRUE;
ELSIF CheckAllChildAlmClass(E_AlmClass.OFF) THEN
	CIf.Job.eMe_ActivAlmClass := E_AlmClass.OFF;
	me.Alarm.bolfp := TRUE;
ELSIF CheckAllChildAlmClass(E_AlmClass.STOP) THEN
	CIf.Job.eMe_ActivAlmClass := E_AlmClass.STOP;
	me.Alarm.bolfp := TRUE;
ELSIF CheckAllChildAlmClass(E_AlmClass.TSTOP) THEN
	CIf.Job.eMe_ActivAlmClass := E_AlmClass.TSTOP;
	me.Alarm.bolfp := TRUE;
ELSE
	IF (me.Alarm.bolfp) THEN
		CIf.Job.eMe_ActivAlmClass := E_AlmClass.NONE; // no reset necessary
		me.Alarm.bolfp := FALSE;
	END_IF
END_IF

//------------------------------------------------------------------------------------------------------
// set alarm class parent of childs
//------------------------------------------------------------------------------------------------------
// set alarm class parent of childs in the case of a parent EOFF or me=OFF or EOFF
IF (CIf.Job.eParent_ActivAlmClass=E_AlmClass.EOFF) THEN
	SetAllChildAlmClass(CIf.Job.eParent_ActivAlmClass);
ELSIF(CIf.Job.eMe_ActivAlmClass=E_AlmClass.EOFF) OR (CIf.Job.eMe_ActivAlmClass=E_AlmClass.OFF) THEN
	SetAllChildAlmClass(CIf.Job.eMe_ActivAlmClass);
ELSE
	// no important alarm for child active
	SetAllChildAlmClass(E_AlmClass.NONE);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Property Name="SIf_In" Id="{d26d3890-71df-445f-a1ed-19dc5bb456a2}">
      <Declaration><![CDATA[PROPERTY SIf_In : POINTER TO T_Ctrl_SIf_MOD_In
]]></Declaration>
      <Get Name="Get" Id="{3f320967-e01c-4cc5-bd23-c76f74f30200}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[SIf_In:= SIf_MOD.In; ]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{df5e93ad-1f33-4a9c-9d7e-8c01075973b1}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[SIf_MOD.In := SIf_In;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="sta_ERROR" Id="{ebaa0d20-3483-464b-84fb-8ac6d1d7c3da}">
      <Declaration><![CDATA[METHOD PROTECTED sta_ERROR : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateHistory := me.StateMachine.intStateLastCycle; // -> possibillity to go back to state before error
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		// Clear pending command to prevent automatic recovery!
		CIf.Job.intACmd:=cSTA_DONE;
		// In case on an error, set all childs to off
		SetAllChildCmd(cCMD_OFF);
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		;
		// State Change Condition
		IF ((CIf.Job.bolAlmReset = TRUE) AND (CheckAllChildState(cSTA_OFF))) THEN
			me.StateMachine.intStateNext := cSTA_ERRORQuit;
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Property Name="SIf_Cfg" Id="{fb07488b-af83-408e-8562-7c3d8ca56d51}">
      <Declaration><![CDATA[PROPERTY SIf_Cfg : POINTER TO T_Ctrl_SIf_MOD_Cfg
]]></Declaration>
      <Set Name="Set" Id="{4bdf2cf0-a872-4baa-946c-e48205769e7f}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[SIf_MOD.Cfg := SIf_Cfg;]]></ST>
        </Implementation>
      </Set>
      <Get Name="Get" Id="{75166a48-64be-437e-86b7-4f03b090070a}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[SIf_Cfg:= SIf_MOD.Cfg; ]]></ST>
        </Implementation>
      </Get>
    </Property>
    <ObjectProperties />
  </POU>
</TcPlcObject>