<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.0.25">
  <POU Name="FB_CtrlModule" Id="{93bcbc09-e224-4f3b-9fe5-ea80da832953}">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_CtrlModule EXTENDS FB_CtrlBase
VAR_INPUT
	// Emergency circuit OK
	In_bolEmoOk: BOOL;
	// signals that next module is ready
	In_bolReady: BOOL;
END_VAR
VAR_OUTPUT
	// signals that this module is ready
	Out_bolReady: BOOL;
END_VAR
VAR
	/// Timeout supervision of Keep alive Toggle Bit
	udinTimeToggle_ms: UDINT;
	/// Specific interface struct
	SIf_MOD: T_Ctrl_SIf_MOD;
	uinGroupIndex: UINT;
	intCheckCounter: INT;
	uinMaxNrOfGroups: UINT := Base_Const.cMaxNrOfChilds;
	/// List of sequences
	aListOfSeq: ARRAY[0..Base_Const.cMaxNrOfChilds] OF T_Sequence;
	usiNumOfSeq: USINT := 0;
	usiNumOfValidPointerSeqChild: USINT := 0;
	/// [ms] List of waiting times for run sequence until the next group will execute
	/// If wait time is zero, next group will be directly executed after current group.  
	///	aListOfRunGrpWaitTime_ms: ARRAY[0..Base_Const.cMaxNrOfChilds] OF UDINT;
	usiNumOfRunGrpWaitTime: USINT := 0;
	/// [ms] List of waiting times for stop sequence until the next group will execute
	/// If wait time is zero, next group will be directly executed after current group. 
	///	aListOfStopGrpWaitTime_ms: ARRAY[0..Base_Const.cMaxNrOfChilds] OF UDINT;
	usiNumOfStopGrpWaitTime: USINT := 0;
	/// Array includes all registered childs of type IBuffer
	a_IBufferChildCtrl: ARRAY[0..Base_Const.cMaxNrOfChilds] OF IBuffer;
	a_IBufferFullChildCtrl: ARRAY[0..Base_Const.cMaxNrOfChilds] OF IBuffer;
	usiNumOfIBufferChild: USINT;
	usiNumOfIBufferFullChild: USINT;
	/// Counter
	ii: INT;
END_VAR
VAR CONSTANT
	/// sub States for run and stop sequences
	cSTA_SUB_INITIALIZED: INT := 500;
	cSTA_SUB_SEND_GROUP_CMD: INT := 502;
	cSTA_SUB_CHECK_GROUP_STATUS: INT := 504;
	cSTA_SUB_WAIT: INT := 506;
	cSTA_SUB_FINISHED: INT := 508;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*__________________________________________________________________________________________________
¦	
¦	Vistaprint Schweiz GmbH
¦	CH - 8401 Winterthur
¦
¦	www.vistaprint.ch - info@vistaprint.ch
¦___________________________________________________________________________________________________

Function desription:
Basic module controller implementation. This Controller should be the base father controller for all modules in shirt stream. 
e.g. used for ICL, ICB, Loading ...

Controller handle following basic functions:
--------------------------------------------
- Monitoring of common signals from cabinet
- Keep alive bit to line control
- General child handling RUN_busy, STOP_busy sequences and error handling

History:
Version		Date			Author		Comment
---------------------------------------------------------------------------------------------------
0.00.1		06.11.2013		AVM/DSC		Start history
0.00.2		14.11.2013		AVM/MRU		Changes in some methods
0.00.3		29.11.2013		AVM/MRU		Changes in IoInBridge
0.00.4		04.12.2013		AVM/MRU		Changes in Always - EOFFBusy
0.00.5		04.12.2013		AVM/MRU		Changes in Always - EOFFBusy at GeneralError
0.00.6		04.12.2013		AVM/MRU		Changes in Always - EOFFBusy if not in sta_EOFF 
0.00.7		05.12.2013		AVM/DSC		General revision of behaviour in case of emergency off (state EOFF) and general error (state ERROR).
										New handling for module specific interface.
0.00.8		06.12.2013		AVM/MRU		Add TSTOP in checkChildAlmClass
0.00.9		09.12.2013		AVM/DSC		BugFix in sub state "cSTA_SUB_CHECK_GROUP_STATUS" from run and stop sequence. Insert new "bolChecked" flag
						 				to detect if the sequence has been processed correctly.
0.00.10		11.12.2013		AVM/MRU		Clear pending command to prevent automatic recovery in sta_STOPBusy
0.00.11		13.01.2014		AVM/MRU		Bugzilla ID 03: BufferFull added
0.00.12		20.01.2014		AVM/MRU		EMO, general error reworked; AddRunGrp, AddStopGrp removed
										Timeout run/stop group added 
0.00.13		22.01.2014		AVM/MRU		Alternativ status for run sequence added
0.00.14		08.02.2014		VP/RE		Added bolStopReleaseHangers to CUR.

___________________________________________________________________________________________________*)


IF (SIf_MOD.Cur<>0) AND (SIf_MOD.Cfg<>0) AND (SIf_MOD.Par<>0) AND (SIf_MOD.In<>0) THEN // cyclic call enabled
	SUPER^();
END_IF;
]]></ST>
    </Implementation>
    <Method Name="IoOutBridge" Id="{0547fd7b-a1af-4009-8ecb-2ef72dd56f49}">
      <Declaration><![CDATA[METHOD PROTECTED IoOutBridge : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// digitale and analoge inputs read from hardware or forcing
IF (CIf.SwCfg.bolSimulation = FALSE) THEN
	
	setOutBol(CIf.Job.bolIoForce ,ADR(SIf_Out^.bolReady));
	THIS^.Out_bolReady := SIf_Out^.bolReady.map;

	// check interlocks to prevent damages
	IF (CIf.Job.bolIlkOverwrite=FALSE) THEN
	;
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="getCmdState" Id="{12fc8a53-4b7a-4d57-b5d7-3d215ebc1d8b}">
      <Declaration><![CDATA[METHOD PROTECTED getCmdState : STRING
VAR_INPUT
	intCmdState: INT;
	bolState: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCmdState := SUPER^.getCmdState(intCmdState:=intCmdState,bolState:=bolState); // get global/base defined cmds/states
IF (getCmdState='') THEN // global not defined get local
	// get string cmd/state string information in runtime
	IF (bolState=FALSE) THEN
		// cmd's
	ELSE
	
	// cmd's
		CASE intCmdState OF	
			// SUB States
			cSTA_SUB_INITIALIZED:
				getCmdState := 'cSTA_SUB_INITIALIZED';
			cSTA_SUB_SEND_GROUP_CMD:
				getCmdState := 'cSTA_SUB_SEND_GROUP_CMD';
			cSTA_SUB_CHECK_GROUP_STATUS:
				getCmdState := 'cSTA_SUB_CHECK_GROUP_STATUS';
			cSTA_SUB_WAIT:
				getCmdState := 'cSTA_SUB_WAIT';
			cSTA_SUB_FINISHED:
				getCmdState := 'cSTA_SUB_FINISHED';
		END_CASE;
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Always" Id="{2b2066c4-4e8e-4805-ad8b-8de49b1882dd}">
      <Declaration><![CDATA[METHOD PROTECTED Always : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.Always();

// ---------------------------------------------------------------------------------
// Simulation
IF (CIf.SwCfg.bolSimulation) THEN
	SIf_Cur^.bolKeepAliveHost := NOT SIf_Cur^.bolKeepAlivePlc;
	// Simulate inputs from global module for general supervision (no physical inputs)
	SIf_In^.bolEmoOk.intern := TRUE;
	SIf_In^.bolReady.intern := TRUE;
END_IF

// ----------------------------------------------------------------------------------
// cyclic actions outside of statemachine
IF (me.StateMachine.intState<>cSTA_SINGLE_ANSWER) THEN
	
	//-------------------------------------------------------------------------------
	// Monitoring of inputs from global module (no physical inputs)
	//-------------------------------------------------------------------------------
	
	SIf_Out^.bolReady.intern :=		((me.StateMachine.intState = BASE_PLC.cSTA_RUN) OR (me.StateMachine.intState = BASE_PLC.cSTA_RUNBusy))
								AND	(me.Alarm.eActivAlmClass <> BASE_PLC.E_AlmClass.TSTOP)	//TODO
								AND	(me.Alarm.eActivAlmClass <> BASE_PLC.E_AlmClass.EOFF);	//TODO
								
	IF NOT (SIf_In^.bolReady.intern OR SIf_Cfg^.bolIgnoreReadyInput) THEN
		//SIf_MOD.Alm[E_ALM_MOD.NextModuleNotReady].strText := 'Next Module is not Ready';
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_MOD.NextModuleNotReady,0,ADR(SIf_MOD.Alm),E_AlmState.SET,CIf.Job.eMe_ActivAlmClass);
		CIf.Job.intACmd := cCMD_DONE;	//TODO
	ELSE
		//SIf_MOD.Alm[E_ALM_MOD.NextModuleNotReady].strText := 'Next Module is not Ready';
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_MOD.NextModuleNotReady,0,ADR(SIf_MOD.Alm),E_AlmState.CLR,CIf.Job.eMe_ActivAlmClass);
	END_IF
	
	// Emergency Off
	IF ((SIf_In^.bolEmoOk.intern = FALSE) AND (me.StateMachine.intState <> cSTA_EOFF) AND (me.StateMachine.intState <> cSTA_EOFFBusy)
		AND (me.StateMachine.intState <> cSTA_ERROR) AND (me.StateMachine.intState <> cSTA_ERRORQuit)) THEN
		me.StateMachine.intStateNext := cSTA_EOFFBusy;				
	END_IF
	// As long as EMO is not OK, set Alarm
	IF (SIf_In^.bolEmoOk.intern = FALSE) AND ((me.StateMachine.intState = cSTA_EOFF) OR (me.StateMachine.intState = cSTA_EOFFBusy)) THEN
		//SIf_MOD.Alm[E_ALM_MOD.EmergencyOff].strText := 'Emergency off active';
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_MOD.EmergencyOff,0,ADR(SIf_MOD.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
	END_IF
	
END_IF

//-------------------------------------------------------------------------------
// Keep Alive function to line controller with togglebit
//-------------------------------------------------------------------------------

// Communication to line control enabled
IF (SIf_Cfg^.bolComToLineControlEnabled = TRUE) THEN
	IF (SIf_Cur^.bolKeepAliveHost <> SIf_Cur^.bolKeepAlivePlc) THEN
		udinTimeToggle_ms := 0;
		SIf_Cur^.bolKeepAlivePlc := SIf_Cur^.bolKeepAliveHost;
	ELSE
		IF (udinTimeToggle_ms >= SIf_Par^.udiComTimeOutLineCtrl_ms) THEN
			//SIf_MOD.Alm[E_ALM_MOD.CommunicationError].strText := 'Communication error to line control'; 
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_MOD.CommunicationError,UDINT_TO_DINT(udinTimeToggle_ms),ADR(SIf_MOD.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);	
			me.StateMachine.intStateNext := cSTA_Error;	
		END_IF
		udinTimeToggle_ms:= udinTimeToggle_ms + me.FUBInfo.udiSample_ms;
	END_IF
// Communication to line control disabled
ELSE
	SIf_Cur^.bolKeepAliveHost:= NOT SIf_Cur^.bolKeepAlivePlc;
END_IF

//-------------------------------------------------------------------------------
// Calculate the sum of all hangers in the system and the capacity of the system
//-------------------------------------------------------------------------------
IF (usiNumOfIBufferChild>0) THEN 
	SIf_Cur^.dinNumOfHangers:= 0;
	SIf_Cur^.dinMaxCapacity:= 0;
	FOR ii:= 0 TO (usiNumOfIBufferChild-1) DO
		SIf_Cur^.dinNumOfHangers:= SIf_Cur^.dinNumOfHangers + a_IBufferChildCtrl[ii].NumOfHangers;
		SIf_Cur^.dinMaxCapacity:= SIf_Cur^.dinMaxCapacity + a_IBufferChildCtrl[ii].MaxCapacity;
	END_FOR
END_IF

//-------------------------------------------------------------------------------
// Write BufferFull for LineControl into SIF
//-------------------------------------------------------------------------------
IF (usiNumOfIBufferFullChild>0) THEN 
	FOR ii:= 0 TO (usiNumOfIBufferFullChild-1) DO
		SIf_Cur^.a_bBufferIsFull[ii]:= a_IBufferFullChildCtrl[ii].BufferFull;
	END_FOR
END_IF


// ----------------------------------------------------------------------------------
// Conditions Always

// EOFF exist in FB_CtrlModule. Not overrule.
(*
// overrule error always from base -> no EOFF State!! in EOFF go to OFF
IF (me.StateMachine.intStateNext = cSTA_EOFFBusy) THEN
	IF (me.StateMachine.intState=cSTA_OFF) THEN
		me.StateMachine.intStateNext := cSTA_OFF;
	ELSE // stay in OFF
		me.StateMachine.intStateNext := cSTA_OFFBusy;
	END_IF
*)
IF (me.Alarm.eActivAlmClass=E_AlmClass.STOP) AND (me.StateMachine.intStateNext<>cSTA_Error)
		AND ((me.StateMachine.intState = cSTA_RUN) OR (me.StateMachine.intState = cSTA_RUNBusy))THEN
	// alarm evt STOP
	me.StateMachine.intStateNext := cSTA_STOPBusy;	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_RUN" Id="{2b57d42b-4072-44ef-bdb5-a7ee1dbac08c}">
      <Declaration><![CDATA[METHOD PROTECTED sta_RUN : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		;
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN

		// Simulation
		IF (CIf.SwCfg.bolSimulation) THEN
			;
		END_IF

		// State Change Condition	
		IF (me.intCmd=cCMD_STOP OR NOT (SIf_In^.bolReady.intern OR SIf_Cfg^.bolIgnoreReadyInput))  THEN
			me.StateMachine.intStateNext :=  cSTA_STOPBusy;	
		END_IF

	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_OFF" Id="{3750f796-76b8-4174-8fb8-c3e13e87b7c5}">
      <Declaration><![CDATA[METHOD PROTECTED sta_OFF : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF

	
//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
				
		// State Change Condition
		IF (me.Alarm.eActivAlmClass<>E_AlmClass.EOFF) AND (me.Alarm.eActivAlmClass<>E_AlmClass.OFF) THEN
			IF (me.intCmd=cCMD_RUN AND (SIf_In^.bolReady.intern OR SIf_Cfg^.bolIgnoreReadyInput)) THEN 
				me.StateMachine.intStateNext := cSTA_RUNBusy;
			END_IF
		END_IF
	END_IF

	
//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_EOFFBusy" Id="{43926500-8b3f-40d9-9943-c6ef440eaefb}">
      <Declaration><![CDATA[METHOD PROTECTED sta_EOFFBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF

	
//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// In case of an emergency, set all childs to off 
		// Set in cyclic action because of possible errors or manual/auto changes!
		SUPER^.SetAllChildCmd(BASE_PLC.cCMD_OFF);

		// check if all childs have reached the state
		IF CheckAllChildState(cSTA_OFF) THEN
			me.StateMachine.intStateNext := cSTA_EOFF;
		END_IF
	END_IF

	
//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_STOP" Id="{44340596-81ec-4934-a2c3-05ad5626426e}">
      <Declaration><![CDATA[METHOD PROTECTED sta_STOP : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// State Change Condition
		IF (me.Alarm.eActivAlmClass<>E_AlmClass.STOP) THEN
			IF (me.intCmd=cCMD_RUN AND (SIf_In^.bolReady.intern OR SIf_Cfg^.bolIgnoreReadyInput)) THEN
				me.StateMachine.intStateNext :=  cSTA_RUNBusy;
			END_IF
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_RUNBusy" Id="{459b0430-9f25-4ebc-ba23-68dcaa75419d}">
      <Declaration><![CDATA[METHOD PROTECTED sta_RUNBusy : BOOL
VAR
	ii: INT;
	bolFurtherGrpExist: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		// Init sub state machine
		me.SubStateMachine.intState := cSTA_SUB_INITIALIZED; 
		me.SubStateMachine.intStateNext := cSTA_SUB_INITIALIZED;
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN

		// Simulation
		IF (CIf.SwCfg.bolSimulation) THEN
			;
		END_IF
	
		// Start Cycle with substates	
		//--------------------------------------------------------------------------------------
		// sub state machine for sequence
		CASE me.SubStateMachine.intState OF
			//--------------------------------------------------------------------------------------
			cSTA_SUB_INITIALIZED:
			
				// Loop over all registered childs
				FOR ii:=0 TO usiNumOfSeq-1 BY 1 DO
					// Clear checked flag		
					aListOfSeq[ii].bolChecked:= FALSE;
				END_FOR
				uinGroupIndex:= 1;
				me.SubStateMachine.intStateNext := cSTA_SUB_SEND_GROUP_CMD;
				
			cSTA_SUB_SEND_GROUP_CMD:
				
				intCheckCounter:= 0;
				// Loop over all registered childs
				FOR ii:=0 TO usiNumOfSeq-1 BY 1 DO
					// If child is associated for the current group index		
					IF (aListOfSeq[ii].uinGroupRun = uinGroupIndex) THEN
						// Send defined command
						aListOfSeq[ii].pCIF^.Job.intACmd:= aListOfSeq[ii].intCmdSeqRun;
						intCheckCounter:= intCheckCounter + 1;
					END_IF			
				END_FOR
				// Change state
				me.SubStateMachine.intStateNext := cSTA_SUB_CHECK_GROUP_STATUS;
			
			
			cSTA_SUB_CHECK_GROUP_STATUS:
	
				// Loop over all registered childs
				FOR ii:=0 TO usiNumOfSeq-1 BY 1 DO
					// If child is associated for the current group index		
					IF (aListOfSeq[ii].uinGroupRun = uinGroupIndex) THEN
						// Check defined status and if child not already checked
						IF (((aListOfSeq[ii].pCIF^.Job.intState = aListOfSeq[ii].intStatusSeqRun) OR 
						(aListOfSeq[ii].pCIF^.Job.intState = aListOfSeq[ii].intStatusSeqRun2)) AND (aListOfSeq[ii].bolChecked = FALSE)) THEN
							aListOfSeq[ii].bolChecked:= TRUE;
							intCheckCounter:= intCheckCounter - 1;
						END_IF				
					END_IF			
				END_FOR
				
				// All childs in group has the right state
				IF (intCheckCounter <= 0) THEN		
					bolFurtherGrpExist:= FALSE;
					// Check if a further group exist!	
					FOR ii:=0 TO usiNumOfSeq-1 BY 1 DO	
						IF (aListOfSeq[ii].uinGroupRun > uinGroupIndex) THEN
							bolFurtherGrpExist:= TRUE;
							EXIT;
						END_IF			
					END_FOR
					// further group exist
					IF (bolFurtherGrpExist = TRUE) THEN
						IF (uinGroupIndex < uinMaxNrOfGroups) THEN			
							me.SubStateMachine.intStateNext := cSTA_SUB_WAIT;	
						END_IF
					ELSE
						me.SubStateMachine.intStateNext := cSTA_SUB_FINISHED;		
					END_IF
				END_IF

			cSTA_SUB_WAIT:
				
				IF (me.SubStateMachine.udiTimeInState_ms >= SIf_Par^.aListOfRunGrpWaitTime_ms[uinGroupIndex-1]) THEN
					// Inc. group index 
					uinGroupIndex:= uinGroupIndex + 1;	
					// Change state, send command for next group
					me.SubStateMachine.intStateNext := cSTA_SUB_SEND_GROUP_CMD;
				END_IF
			
			cSTA_SUB_FINISHED:
					;		
		END_CASE
		
		// Check time out error
		IF (SIf_MOD.Par^.udiTimeoutStarting_ms <> 0) AND (me.SubStateMachine.udiTimeInState_ms > (SIf_Par^.aListOfRunGrpWaitTime_ms[uinGroupIndex-1] + SIf_MOD.Par^.udiTimeoutStarting_ms)) THEN
			//SIf_MOD.Alm[E_ALM_MOD.TimeoutStarGroup].strText := 'Timeout start group';
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_MOD.TimeoutStartGroup,uinGroupIndex,ADR(SIf_MOD.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
		END_IF
		
		// State Change Condition
		IF (me.intCmd=cCMD_STOP OR NOT (SIf_In^.bolReady.intern OR SIf_Cfg^.bolIgnoreReadyInput)) THEN
			me.StateMachine.intStateNext :=  cSTA_STOPBusy;	
		ELSIF (me.SubStateMachine.intState = cSTA_SUB_FINISHED) THEN
			me.StateMachine.intStateNext := cSTA_RUN;
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="CheckAllChildStateOr" Id="{4a6c1c11-1b34-4eb9-a328-d882760ab423}">
      <Declaration><![CDATA[{attribute 'object_name' := 'CheckAllChildStateOr'}
METHOD PROTECTED CheckAllChildStateOr : BOOL
VAR_INPUT
	In_intCheckState1: INT;
	In_intCheckState2: INT;
END_VAR
VAR
	uinIdx: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// check if all child controller have reached one of the two In_intCheckState
CheckAllChildStateOr := TRUE;
IF (CIf.Info.uinChildNbr > 0) THEN
	FOR uinIdx := 0 TO CIf.Info.uinChildNbr - 1 DO
		CheckAllChildStateOr := CheckAllChildStateOr AND ((CIf.Info.p_aCIf[uinIdx]^.Job.intState = In_intCheckState1) OR (CIf.Info.p_aCIf[uinIdx]^.Job.intState = In_intCheckState2));
		IF (CheckAllChildStateOr=FALSE) THEN	// at least one child has not whished state reached
			EXIT ;
		END_IF 
	END_FOR
END_IF]]></ST>
      </Implementation>
    </Method>
    <Property Name="SIf_Out" Id="{66efe5fb-6c08-4450-a924-f790660b37a8}">
      <Declaration><![CDATA[PROPERTY SIf_Out : POINTER TO T_Ctrl_SIf_MOD_Out]]></Declaration>
      <Set Name="Set" Id="{04a68e53-e094-401a-ba3b-ad0a8d642962}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[SIf_MOD.Out := SIf_Out;]]></ST>
        </Implementation>
      </Set>
      <Get Name="Get" Id="{61394655-9375-4a7c-810b-65c507df63a0}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[SIf_Out:= SIf_MOD.Out; ]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="CtrlInit" Id="{7a0ac12c-cff4-4e9e-8849-3ec85fb70fac}">
      <Declaration><![CDATA[METHOD PUBLIC CtrlInit : BOOL
VAR
	ii: INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.CtrlInit();

// Initialize all child controller
// Childs are listed in list of sequences
FOR ii:=0 TO usiNumOfSeq-1 BY 1 DO	
	aListOfSeq[ii].pCIF := THIS^.AddChild(aListOfSeq[ii].pChild^);
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_EOFF" Id="{7a7e2512-7c7d-4cf3-97d1-a6e983988ed7}">
      <Declaration><![CDATA[METHOD PROTECTED sta_EOFF : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;	
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN		
		
		// As long as the EMO is not reseted!
		IF NOT (SIf_In^.bolEmoOk.intern) THEN
			// Clear pending and new commands cyclic to prevent automatic recovery!
			CIf.Job.intACmd := BASE_PLC.cCMD_DONE;
			CIf.Job.intMCmd := BASE_PLC.cCMD_DONE;
		END_IF
	
		// State Change Condition
		IF (SIf_In^.bolEmoOk.intern) AND (me.Alarm.eActivAlmClass<>E_AlmClass.EOFF) AND (me.intCmd<>BASE_PLC.cCMD_EOFF) AND (me.intCmd<>BASE_PLC.cCMD_DONE) THEN
			me.StateMachine.intStateNext := cSTA_OFF;
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="checkValidPointer" Id="{7bc44136-2728-423e-a49d-d06c4040b9ac}">
      <Declaration><![CDATA[METHOD PROTECTED checkValidPointer : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (usiNumOfSeq = usiNumOfValidPointerSeqChild) AND (SIf_Cfg<>0) AND (SIf_Par<>0) AND (SIf_Cur<>0) AND (SIf_In<>0) THEN
	checkValidPointer:= TRUE;
ELSE
	// Invalid child pointer
	checkValidPointer:= FALSE;	
	//SIf_MOD.Alm[E_ALM_MOD.InvalidPointer].strText := 'Invalid pointer';
	pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_MOD.InvalidPointer,0,ADR(SIf_MOD.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);	
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddIBufferFullChilds" Id="{7bcb42ec-0ed0-4411-889a-451df2a9d0ed}">
      <Declaration><![CDATA[METHOD AddIBufferFullChilds
VAR_INPUT
	pFB_ChildTypeIBuffer: POINTER TO FB_IBuffer;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Method add childs with BufferFull information to the array
IF (usiNumOfIBufferFullChild <= (Base_Const.cMaxNrOfChilds-1)) THEN
	// Add child controller to list
	a_IBufferFullChildCtrl[usiNumOfIBufferFullChild] := pFB_ChildTypeIBuffer^;

	// Inc. number of IBufferFull childs
	usiNumOfIBufferFullChild:= usiNumOfIBufferFullChild+1;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Property Name="SIf_Cur" Id="{7c2240cf-17ab-4950-a777-bd60151c9f81}">
      <Declaration><![CDATA[PROPERTY SIf_Cur : POINTER TO T_Ctrl_SIf_MOD_Cur
]]></Declaration>
      <Set Name="Set" Id="{aec5c1a4-65f2-404c-8954-9252443dd039}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[SIf_MOD.Cur := SIf_Cur; ]]></ST>
        </Implementation>
      </Set>
      <Get Name="Get" Id="{b3d9c14f-7bba-46aa-8d01-2c4134f173fd}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[SIf_Cur:= SIf_MOD.Cur; ]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="IoInBridge" Id="{95c556ec-c88e-4a00-9f2f-5c4a543adc13}">
      <Declaration><![CDATA[METHOD PROTECTED IoInBridge : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[// digitale and analoge inputs read from hardware or forcing
SIf_In^.bolReady.map	:= THIS^.In_bolReady;
SIf_In^.bolEmoOk.map	:= THIS^.In_bolEmoOk;

IF (CIf.SwCfg.bolSimulation = FALSE) THEN
	BASE_PLC.getInBol(CIf.Job.bolIoForce,ADR(SIf_In^.bolReady));
	BASE_PLC.getInBol(CIf.Job.bolIoForce,ADR(SIf_In^.bolEmoOk));
ELSE
	//simulation of global IO
	SIf_In^.bolReady.intern	:= TRUE;
	SIf_In^.bolEmoOk.intern	:= FALSE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddSeqChild" Id="{a0025313-0b7e-4dba-80b1-83806b0c4ebe}">
      <Declaration><![CDATA[METHOD AddSeqChild
VAR_INPUT
	stSequence: T_Sequence;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Method add a sequence to list
IF (usiNumOfSeq <= (Base_Const.cMaxNrOfChilds-1)) THEN
	aListOfSeq[usiNumOfSeq].pChild:= stSequence.pChild;
	aListOfSeq[usiNumOfSeq].uinGroupRun:= stSequence.uinGroupRun;
	aListOfSeq[usiNumOfSeq].uinGroupStop:= stSequence.uinGroupStop;
	aListOfSeq[usiNumOfSeq].intCmdSeqRun:= stSequence.intCmdSeqRun;
	aListOfSeq[usiNumOfSeq].intStatusSeqRun:= stSequence.intStatusSeqRun;
	aListOfSeq[usiNumOfSeq].intStatusSeqRun2:= stSequence.intStatusSeqRun2;
	aListOfSeq[usiNumOfSeq].intCmdSeqStop:= stSequence.intCmdSeqStop;
	aListOfSeq[usiNumOfSeq].intStatusSeqStop:= stSequence.intStatusSeqStop;
	// Inc. number of sequence
	usiNumOfSeq:= usiNumOfSeq+1;
	// Check if the pointer is valid
	IF (stSequence.pChild<>0) THEN
		usiNumOfValidPointerSeqChild:= usiNumOfValidPointerSeqChild+1;
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_PONBusy" Id="{b12c82f9-e8f5-4662-8a55-255f28b471bf}">
      <Declaration><![CDATA[{attribute 'object_name' := 'sta_PONBusy'}
METHOD PROTECTED sta_PONBusy : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		SetAllChildCmd(cCMD_PON); // set acmd off all childs 
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN

		// State Change Condition
		IF (FALSE) THEN
			;
		ELSIF CheckAllChildStateOr(cSTA_PON, cSTA_RUN) THEN
			me.StateMachine.intStateNext := cSTA_PON;
		END_IF
		
	END_IF


//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_STOPBusy" Id="{b4344b3d-9889-41b7-a53d-b3ca5d0bce3a}">
      <Declaration><![CDATA[METHOD PROTECTED sta_STOPBusy : BOOL
VAR
	ii: INT;
	bolFurtherGrpExist: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;	
		// Init sub state machine
		me.SubStateMachine.intState := cSTA_SUB_INITIALIZED; 
		me.SubStateMachine.intStateNext := cSTA_SUB_INITIALIZED;
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN

		// Simulation
		IF (CIf.SwCfg.bolSimulation) THEN
			;
		END_IF
		
		// Stop Cycle with substates	
		//--------------------------------------------------------------------------------------
		// sub state machine for sequence
		CASE me.SubStateMachine.intState OF
			//--------------------------------------------------------------------------------------
			cSTA_SUB_INITIALIZED:
			
				// Loop over all registered childs
				FOR ii:=0 TO usiNumOfSeq-1 BY 1 DO
					// Clear checked flag		
					aListOfSeq[ii].bolChecked:= FALSE;
				END_FOR
				uinGroupIndex:= 1;
				me.SubStateMachine.intStateNext := cSTA_SUB_SEND_GROUP_CMD;
				
			cSTA_SUB_SEND_GROUP_CMD:
				
				intCheckCounter:= 0;
				// Loop over all registered childs
				FOR ii:=0 TO usiNumOfSeq-1 BY 1 DO
					// If child is associated for the current group index		
					IF (aListOfSeq[ii].uinGroupStop = uinGroupIndex) THEN
						// Send defined command
						aListOfSeq[ii].pCIF^.Job.intACmd:= aListOfSeq[ii].intCmdSeqStop;
						intCheckCounter:= intCheckCounter + 1;
					END_IF			
				END_FOR
				// Change state
				me.SubStateMachine.intStateNext := cSTA_SUB_CHECK_GROUP_STATUS;
			
			
			cSTA_SUB_CHECK_GROUP_STATUS:
	
				// Loop over all registered childs
				FOR ii:=0 TO usiNumOfSeq-1 BY 1 DO
					// If child is associated for the current group index		
					IF (aListOfSeq[ii].uinGroupStop = uinGroupIndex) THEN
						// Check defined status and if child not already checked
						IF ((aListOfSeq[ii].pCIF^.Job.intState = aListOfSeq[ii].intStatusSeqStop) AND (aListOfSeq[ii].bolChecked = FALSE)) THEN
							aListOfSeq[ii].bolChecked:= TRUE;
							intCheckCounter:= intCheckCounter - 1;
						END_IF				
					END_IF			
				END_FOR
				
				// All childs in group has the right state
				IF (intCheckCounter <= 0) THEN		
					bolFurtherGrpExist:= FALSE;
					// Check if a further group exist!	
					FOR ii:=0 TO usiNumOfSeq-1 BY 1 DO	
						IF (aListOfSeq[ii].uinGroupStop > uinGroupIndex) THEN
							bolFurtherGrpExist:= TRUE;
							EXIT;
						END_IF			
					END_FOR
					// further group exist
					IF (bolFurtherGrpExist = TRUE) THEN
						IF (uinGroupIndex < uinMaxNrOfGroups) THEN			
							me.SubStateMachine.intStateNext := cSTA_SUB_WAIT;	
						END_IF
					ELSE
						me.SubStateMachine.intStateNext := cSTA_SUB_FINISHED;		
					END_IF
				END_IF

			cSTA_SUB_WAIT:
				
				IF (me.SubStateMachine.udiTimeInState_ms >= SIf_Par^.aListOfStopGrpWaitTime_ms[uinGroupIndex-1]) THEN
					// Inc. group index 
					uinGroupIndex:= uinGroupIndex + 1;	
					// Change state, send command for next group
					me.SubStateMachine.intStateNext := cSTA_SUB_SEND_GROUP_CMD;
				END_IF
			
			cSTA_SUB_FINISHED:
					;		
		END_CASE
		
		// Check time out error
		IF (SIf_MOD.Par^.udiTimeoutStopping_ms <> 0) AND (me.SubStateMachine.udiTimeInState_ms > (SIf_Par^.aListOfStopGrpWaitTime_ms[uinGroupIndex-1] + SIf_MOD.Par^.udiTimeoutStopping_ms)) THEN
			//SIf_MOD.Alm[E_ALM_MOD.TimeoutStopGroup].strText := 'Timeout stop group';
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,E_ALM_MOD.TimeoutStopGroup,uinGroupIndex,ADR(SIf_MOD.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
		END_IF
	
		// State Change Condition
		IF (me.SubStateMachine.intState = cSTA_SUB_FINISHED) THEN
			me.StateMachine.intStateNext := cSTA_STOP;
		ELSIF (me.intCmd=cCMD_RUN) THEN
			// State Change Condition
			IF (me.Alarm.eActivAlmClass<>E_AlmClass.STOP) THEN	
				me.StateMachine.intStateNext := cSTA_RUNBusy;	
			ELSE
				// Clear pending command to prevent automatic recovery!
				CIf.Job.intACmd:=cSTA_DONE;
			END_IF
		END_IF

	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Property Name="SIf_Par" Id="{b5260abe-a3fb-44c5-b308-7b394f794cb8}">
      <Declaration><![CDATA[PROPERTY SIf_Par : POINTER TO T_Ctrl_SIf_MOD_Par
]]></Declaration>
      <Set Name="Set" Id="{1ab8c3a9-59cf-4579-8f81-7e3553ee6144}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[SIf_MOD.Par := SIf_Par; ]]></ST>
        </Implementation>
      </Set>
      <Get Name="Get" Id="{fbeb4499-4f6e-48f1-8396-50521ce2dda3}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[SIf_Par:= SIf_MOD.Par; ]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="FB_init" Id="{ba738ca1-fd3b-440c-bfd2-18e244ab5591}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	///if TRUE, the retain variables are initialized (warm start / cold start)
	bInitRetains: BOOL;
	///if TRUE, the instance afterwards gets moved into the copy code (online change)
	bInCopyCode: BOOL;
END_VAR
VAR
	ii: UINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// to manually change in new FUB implementation!!!
// define valid commands for this controller
FOR ii:= 0 TO (SIZEOF(CIf.Job.aCmdList)/SIZEOF(CIf.Job.aCmdList[0])-1) BY 1 DO
	IF (CIf.Job.aCmdList[ii].intCmd=cCMD_INITIALIZED) THEN
		// found first empty array element
		EXIT;
	END_IF
END_FOR

CIf.Job.aCmdList[ii].intCmd := cCMD_RUN;
CIf.Job.aCmdList[ii].strName := 'Run'; 
CIf.Job.aCmdList[ii].bolAvailable := TRUE;
ii := ii +1;
CIf.Job.aCmdList[ii].intCmd := cCMD_STOP;
CIf.Job.aCmdList[ii].strName := 'Stop'; 
CIf.Job.aCmdList[ii].bolAvailable := TRUE;
ii := ii +1;

// set name of class/typ
CIf.Info.strType := 'FB_CtrlModule';
CIf.Info.strFullName := 'Base Controller Module';

// set alarm class
SIf_MOD.Alm[E_ALM_MOD.InvalidPointer].eAlmClass := E_AlmClass.STOP;
SIf_MOD.Alm[E_ALM_MOD.InvalidPointer].strText := 'Invalid pointer';
SIf_MOD.Alm[E_ALM_MOD.CommunicationError].eAlmClass := E_AlmClass.OFF;
SIf_MOD.Alm[E_ALM_MOD.CommunicationError].strText := 'Communication error to line control';
SIf_MOD.Alm[E_ALM_MOD.EmergencyOff].eAlmClass := E_AlmClass.EOFF;
SIf_MOD.Alm[E_ALM_MOD.EmergencyOff].strText := 'Emergency off active';
SIf_MOD.Alm[E_ALM_MOD.TimeoutStartGroup].eAlmClass := E_AlmClass.OFF;
SIf_MOD.Alm[E_ALM_MOD.TimeoutStartGroup].strText := 'Timeout start group';
SIf_MOD.Alm[E_ALM_MOD.TimeoutStopGroup].eAlmClass := E_AlmClass.OFF;
SIf_MOD.Alm[E_ALM_MOD.TimeoutStopGroup].strText := 'Timeout stop group';
SIf_MOD.Alm[E_ALM_MOD.NextModuleNotReady].eAlmClass := E_AlmClass.STOP;	//TODO
SIf_MOD.Alm[E_ALM_MOD.NextModuleNotReady].strText := 'Next Module is not Ready';

//*******************************************************************************
// initial values
//*******************************************************************************
udinTimeToggle_ms := 0;
// software configuration
CIf.SwCfg.bolExist := TRUE;
CIf.SwCfg.bolSimulation := FALSE;

// No initialization for cfg and par in this base module!
// Pointer address of the property is not defined at this time]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddIBufferChilds" Id="{bc49a60a-0556-4ce3-b7de-195ad0ea1e2e}">
      <Declaration><![CDATA[METHOD AddIBufferChilds
VAR_INPUT
	pFB_ChildTypeIBuffer: POINTER TO FB_IBuffer;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Method add childs with type of IBuffer to the array
IF (usiNumOfIBufferChild <= (Base_Const.cMaxNrOfChilds-1)) THEN
	// Add child controller to list
	a_IBufferChildCtrl[usiNumOfIBufferChild] := pFB_ChildTypeIBuffer^;
	// Inc. number of IBuffer childs
	usiNumOfIBufferChild:= usiNumOfIBufferChild+1;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="StateMachine" Id="{c244d7e5-c41f-489f-97da-65b69148df4b}">
      <Declaration><![CDATA[METHOD PROTECTED StateMachine : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.StateMachine();

// main statemachine of base controller
CASE me.StateMachine.intState OF
	cSTA_RUN: 
        THIS^.sta_RUN();
    cSTA_RUNBusy: 
        THIS^.sta_RUNBusy();
	cSTA_STOP: 
        THIS^.sta_STOP();
    cSTA_STOPBusy: 
        THIS^.sta_STOPBusy();
END_CASE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="checkChildAlmClass" Id="{cbf90ddf-9131-406d-b67f-19452c240e46}">
      <Declaration><![CDATA[METHOD checkChildAlmClass : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//------------------------------------------------------------------------------------------------------
// check child alarm classes
// set me alarm class active if at least one child has an EOFF
IF CheckAllChildAlmClass(E_AlmClass.EOFF) THEN
	CIf.Job.eMe_ActivAlmClass := E_AlmClass.EOFF;
	me.Alarm.bolfp := TRUE;
ELSIF CheckAllChildAlmClass(E_AlmClass.OFF) THEN
	CIf.Job.eMe_ActivAlmClass := E_AlmClass.OFF;
	me.Alarm.bolfp := TRUE;
ELSIF CheckAllChildAlmClass(E_AlmClass.STOP) THEN
	CIf.Job.eMe_ActivAlmClass := E_AlmClass.STOP;
	me.Alarm.bolfp := TRUE;
ELSIF CheckAllChildAlmClass(E_AlmClass.TSTOP) THEN
	CIf.Job.eMe_ActivAlmClass := E_AlmClass.TSTOP;
	me.Alarm.bolfp := TRUE;
ELSE
	IF (me.Alarm.bolfp) THEN
		CIf.Job.eMe_ActivAlmClass := E_AlmClass.NONE; // no reset necessary
		me.Alarm.bolfp := FALSE;
	END_IF
END_IF

//------------------------------------------------------------------------------------------------------
// set alarm class parent of childs
//------------------------------------------------------------------------------------------------------
// set alarm class parent of childs in the case of a parent EOFF or me=OFF or EOFF
IF (CIf.Job.eParent_ActivAlmClass=E_AlmClass.EOFF) THEN
	SetAllChildAlmClass(CIf.Job.eParent_ActivAlmClass);
ELSIF(CIf.Job.eMe_ActivAlmClass=E_AlmClass.EOFF) OR (CIf.Job.eMe_ActivAlmClass=E_AlmClass.OFF) THEN
	SetAllChildAlmClass(CIf.Job.eMe_ActivAlmClass);
ELSE
	// no important alarm for child active
	SetAllChildAlmClass(E_AlmClass.NONE);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Property Name="SIf_In" Id="{d26d3890-71df-445f-a1ed-19dc5bb456a2}">
      <Declaration><![CDATA[PROPERTY SIf_In : POINTER TO T_Ctrl_SIf_MOD_In
]]></Declaration>
      <Get Name="Get" Id="{3f320967-e01c-4cc5-bd23-c76f74f30200}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[SIf_In:= SIf_MOD.In; ]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{df5e93ad-1f33-4a9c-9d7e-8c01075973b1}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[SIf_MOD.In := SIf_In;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="sta_ERROR" Id="{ebaa0d20-3483-464b-84fb-8ac6d1d7c3da}">
      <Declaration><![CDATA[METHOD PROTECTED sta_ERROR : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateHistory := me.StateMachine.intStateLastCycle; // -> possibillity to go back to state before error
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		// Clear pending command to prevent automatic recovery!
		CIf.Job.intACmd:=cSTA_DONE;
		// In case on an error, set all childs to off
		SetAllChildCmd(cCMD_OFF);
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		;
		// State Change Condition
		IF ((CIf.Job.bolAlmReset = TRUE) AND (CheckAllChildState(cSTA_OFF))) THEN
			me.StateMachine.intStateNext := cSTA_ERRORQuit;
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Property Name="SIf_Cfg" Id="{fb07488b-af83-408e-8562-7c3d8ca56d51}">
      <Declaration><![CDATA[PROPERTY SIf_Cfg : POINTER TO T_Ctrl_SIf_MOD_Cfg
]]></Declaration>
      <Set Name="Set" Id="{4bdf2cf0-a872-4baa-946c-e48205769e7f}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[SIf_MOD.Cfg := SIf_Cfg;]]></ST>
        </Implementation>
      </Set>
      <Get Name="Get" Id="{75166a48-64be-437e-86b7-4f03b090070a}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[SIf_Cfg:= SIf_MOD.Cfg; ]]></ST>
        </Implementation>
      </Get>
    </Property>
    <ObjectProperties />
  </POU>
</TcPlcObject>