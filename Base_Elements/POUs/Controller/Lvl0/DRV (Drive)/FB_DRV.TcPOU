<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.0.23">
  <POU Name="FB_DRV" Id="{0608deb6-6173-4434-9b72-4b6d17e0c080}">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_DRV EXTENDS FB_CtrlBase
VAR_INPUT
	In_bolOverload: BOOL;
	In_bolPulse: BOOL;
	In_a_bolBlockedSupvervis: ARRAY[1..cMAX_BLOCKED_SUP] OF BOOL;
	In_bolMaintenanceSwitch: BOOL;
END_VAR
VAR_OUTPUT
	Out_bolSpeed_1: BOOL;
	Out_bolSpeed_2: BOOL;
END_VAR
VAR
	/// Specific interface struct for public access
	SIf: T_Ctrl_SIf_DRV;
	bolPulseFlag: BOOL;
	udiPulseTimeoutTimer: UDINT;
	/// Timer for speed average calculation
	udiTimerSpeedCalc: UDINT;
	/// Shift register for average calculation of the speed
	aSpeedShift: ARRAY[0..4] OF DINT;
	/// Size of Speed Shift array for average calculation
	intSpeedShiftSize: INT;
	/// Varible for Speedcalculation
	dinSpeedCalc_um_s: DINT;
	/// Varible for Speedcalculation
	dinSpeedNew_um_s: DINT;
	/// Old Position for Speed calculation
	dinPosOld_um: DINT;
	/// Loop variable
	intI: INT;
	/// Blocked supervision
	/// Array with supervision distances
	a_dintPinDistance: ARRAY[1..cMAX_BLOCKED_SUP] OF DINT;
	a_bolREBlockedSupvervis: ARRAY[1..cMAX_BLOCKED_SUP] OF BOOL;
	/// Old Position for from last cycle
	dinPosOldCycle_um: DINT;
END_VAR
VAR CONSTANT
	/// Check speed every 250ms
	cSpeedCalcTime_ms: UDINT := 250;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*__________________________________________________________________________________________________
¦	
¦	Vistaprint Schweiz GmbH
¦	CH - 8401 Winterthur
¦
¦	www.vistaprint.ch - info@vistaprint.ch
¦___________________________________________________________________________________________________

Function desription:
Drive element for all different Drive types, 
Configuration of the type and Speed Calculation


History:
Version		Date			Author		Comment
---------------------------------------------------------------------------------------------------
0.00.1		27.06.2013		VP/RE		Start history
0.00.2		28.08.2013		AVME/PRE	Implement speed calculation
0.00.3		19.09.2013		AVME/PRE	Implement new Base Concept
0.00.4		02.10.2013		VP/RE		Added pulse counter. Changed pulse distance to 28.4 mm as a default value. Changed driving distance to 305 mm.
0.00.5      10.10.2013		AVME/DSC    In_bolBufferFull deleted. Not needed in DRV controller. Handled by parent controller if necessary.
0.00.6      18.10.2013		AVME/DSC    SIf.Alm[4].strText deleted in FB_init. Not used anymore.
0.00.7		22.10.2013		AVME/MRU	DRV without pulse sensor simulated pulse imroved
0.00.8      23.10.2013		AVME/DSC    Speed calculation from always to state RUN. cSpeedCalcTime_ms -> 250ms. Shift register array 0..4. Clear buffer in state RUN entry action.
										Changes for better position interpolation in controllers like MER, DPJ, DHC and JUN.
0.00.9		09.07.2014		AVME/MRU	Add Maintenance Switch to Drive (Used in Windsor)
										
___________________________________________________________________________________________________*)


IF (me.bolActivate) THEN // cyclic call enabled
	IF (CIf.Info.bolInitDone=FALSE) THEN // first cycle -> init
		CtrlInit();
		CIf.Info.bolInitDone := TRUE;
	ELSE
		CycleStartDuty();
	
		Always();
		
		StateMachine();
		
		CycleEndDuty();
	END_IF
END_IF;
]]></ST>
    </Implementation>
    <Method Name="IoOutBridge" Id="{0221e71e-2a15-458a-93e2-35e413b2b7cb}">
      <Declaration><![CDATA[METHOD PROTECTED IoOutBridge : BOOL
VAR
	bolSwitchValvesOff: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// digitale and analoge inputs read from hardware or forcing
IF (CIf.SwCfg.bolSimulation = FALSE) THEN
	setOutBol(CIf.Job.bolIoForce ,ADR(SIf.Out.bolSpeed_1));
	setOutBol(CIf.Job.bolIoForce ,ADR(SIf.Out.bolSpeed_2));

	THIS^.Out_bolSpeed_1 := SIf.Out.bolSpeed_1.map;
	THIS^.Out_bolSpeed_2 := SIf.Out.bolSpeed_2.map;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{1004a4b7-3ead-483f-87d2-30b83c9efb3c}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	///if TRUE, the retain variables are initialized (warm start / cold start)
	bInitRetains: BOOL;
	///if TRUE, the instance afterwards gets moved into the copy code (online change)
	bInCopyCode: BOOL;
END_VAR
VAR
	ii: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//------------------------------------------------------------------------------------------------------------------------
// to manually change in new FUB implementation!!!
// define valid commands for this controller
FOR ii:= 0 TO (SIZEOF(CIf.Job.aCmdList)/SIZEOF(CIf.Job.aCmdList[0])-1) BY 1 DO
	IF (CIf.Job.aCmdList[ii].intCmd=cCMD_INITIALIZED) THEN
		// found first empty array element
		EXIT;
	END_IF
END_FOR
CIf.Job.aCmdList[ii].intCmd := cCMD_RUN;
CIf.Job.aCmdList[ii].strName := 'Run'; 
CIf.Job.aCmdList[ii].bolAvailable := TRUE;
ii := ii +1;

// set name of class/typ
CIf.Info.strType := 'FB_DRV'; 

// set alarm class
SIf.Alm[1].eAlmClass := E_AlmClass.OFF;
SIf.Alm[1].strText := 'Drive overload'; 
SIf.Alm[2].eAlmClass := E_AlmClass.OFF;
SIf.Alm[2].strText := 'Timeout no pulse detected';
SIf.Alm[3].eAlmClass := E_AlmClass.OFF;
SIf.Alm[3].strText := 'Drive blocked, Pins are broken';
SIf.Alm[4].eAlmClass := E_AlmClass.OFF;
SIf.Alm[4].strText := 'Maintenance Switch is OFF'; 

//*******************************************************************************
// initial values
//*******************************************************************************

// software configuration
CIf.SwCfg.bolExist := TRUE;
CIf.SwCfg.bolSimulation := FALSE;

// parmeter
SIf.Par.udi_pulseTimeout_ms := 2000;
SIf.Par.udi_pulseSim_ms := 56;
SIf.Par.usi_speedLevel := 0;
SIf.Par.int_MaxBrokenPins := 5;

SIf.Cfg.dinDistPerPulse_um := 28400; // 28,4[mm/puls]
SIf.Cfg.usiCountBlockedSupervis := 0;
SIf.Cfg.dinPinDistance_um := 305000;
SIf.Cfg.bolEnableMaintenaceSwitch := FALSE; // Normaly no Maintenance Switch exist]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_OFFBusy" Id="{11125ebf-7865-4f5d-b12f-6fd3709c0874}">
      <Declaration><![CDATA[METHOD PROTECTED sta_OFFBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		SIf.Out.bolSpeed_1.intern := FALSE;
		SIf.Out.bolSpeed_2.intern := FALSE;
		
		// State Change Condition
		IF (TRUE) THEN
			me.StateMachine.intStateNext := cSTA_OFF;
		END_IF
	END_IF




//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_ERROR" Id="{1ff4d69b-bc03-4b52-b3f6-e4379a15d6ab}">
      <Declaration><![CDATA[METHOD PROTECTED sta_ERROR : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
	me.StateMachine.intStateHistory := me.StateMachine.intStateLastCycle; // -> possibillity to go back to state before error
	me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	
	SIf.Out.bolSpeed_1.intern := FALSE;
	SIf.Out.bolSpeed_2.intern := FALSE;
	
END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		;
		
		
		// State Change Condition
		IF (CIf.Job.bolAlmReset = TRUE) THEN
			me.StateMachine.intStateNext := cSTA_ERRORQuit;
		END_IF
	END_IF




//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Always" Id="{31ffb01b-ebb8-4e32-84fc-c32f32b6d000}">
      <Declaration><![CDATA[METHOD PROTECTED Always : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.Always();

IF (me.StateMachine.intState<>cSTA_SINGLE_ANSWER) THEN
	
	// Error checks not in OFF and Error States
	IF (me.StateMachine.intState<>cSTA_OFF) AND (me.StateMachine.intState<>cSTA_ERROR) AND (me.StateMachine.intState<>cSTA_ERRORQuit) THEN

		IF (SIf.Cfg.bolEnableMaintenaceSwitch AND SIf.In.bolMaintenanceSwitch.intern) THEN
			// SIf.Alm[4].strText := 'Maintenance Switch is OFF'; 
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,4,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);		
			me.StateMachine.intStateNext := cSTA_ERROR;		
		END_IF

		IF SIf.In.bolOverload.intern THEN
			// SIf.Alm[1].strText := 'Drive overload'; 
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,1,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);		
			me.StateMachine.intStateNext := cSTA_ERROR;		
		END_IF
		
		// Blocked Supervision control
		// Sensor detect Pins, if a defined count of pins are brocken, the machine stops
		FOR intI := 1 TO SIf.Cfg.usiCountBlockedSupervis DO
			
			// Simulation
			// Simulate the Pins in the drive
			IF (CIf.SwCfg.bolSimulation) THEN
				IF (a_dintPinDistance[intI] >  SIf.Cfg.dinPinDistance_um) THEN
					SIf.In.a_bolBlockedSupvervis[intI].intern := TRUE;
				ELSE
					SIf.In.a_bolBlockedSupvervis[intI].intern := FALSE;
				END_IF
			END_IF
		
			// Check if a new pin is arrive, set distance to last pin to '0'
			IF ((SIf.In.a_bolBlockedSupvervis[intI].intern = TRUE) AND (a_bolREBlockedSupvervis[intI] = FALSE)) THEN
				a_bolREBlockedSupvervis[intI] := TRUE;
				a_dintPinDistance[intI] := 0;
			ELSIF ((SIf.In.a_bolBlockedSupvervis[intI].intern = FALSE) AND (a_bolREBlockedSupvervis[intI] = TRUE)) THEN
				a_bolREBlockedSupvervis[intI] := FALSE;
			END_IF
			// Check distance to last Pin, if to far away, set error
			IF (a_dintPinDistance[intI] > ((SIf.Par.int_MaxBrokenPins+1) * SIf.Cfg.dinPinDistance_um)) THEN
				// SIf.Alm[3].strText := 'Drive blocked, Pins are broken'; 
				pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,3,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
				a_dintPinDistance[intI] := 0;		
				me.StateMachine.intStateNext := cSTA_ERROR;		
			ELSE
				a_dintPinDistance[intI] := a_dintPinDistance[intI] + SIf.Cur.dinPos_um - dinPosOldCycle_um;					
			END_IF		
		END_FOR
		dinPosOldCycle_um := SIf.Cur.dinPos_um;
	END_IF
END_IF

// Speed calculation in always function to get correct position everytime, not only in run
// observe no pulse detected failure case 
IF (SIf.In.bolPulse.intern AND NOT(bolPulseFlag)) THEN				
	// calculate CUR
	SIf.Cur.dinPos_um := SIf.Cur.dinPos_um + SIf.Cfg.dinDistPerPulse_um;
	SIf.Cur.dinPulseCounter := SIf.Cur.dinPulseCounter + 1;
		
	udiPulseTimeoutTimer := 0;
	bolPulseFlag := TRUE;
ELSIF (NOT(SIf.In.bolPulse.intern) AND bolPulseFlag) THEN
	bolPulseFlag := FALSE;
END_IF

// Always change actions in Base Library
// ----------------------------------------------------------------------------------
// overrule error always from base -> no EOFF State!! in EOFF go to OFF
IF (me.StateMachine.intStateNext = cSTA_EOFFBusy) THEN
	IF (me.StateMachine.intState=cSTA_OFF) THEN
		me.StateMachine.intStateNext := cSTA_OFF;
	ELSE // stay in OFF
		me.StateMachine.intStateNext := cSTA_OFFBusy;
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_OFF" Id="{4b7ba383-48b0-44b2-988b-e4722f4ce08f}">
      <Declaration><![CDATA[METHOD PROTECTED sta_OFF : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		;
		
		
		// State Change Condition
		IF (me.Alarm.eActivAlmClass<>E_AlmClass.EOFF) AND (me.Alarm.eActivAlmClass<>E_AlmClass.OFF) THEN
			IF (me.intCmd=cCMD_RUN) THEN 
				me.StateMachine.intStateNext := cSTA_RUNBusy;
			END_IF
		END_IF
	END_IF




//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_RUN" Id="{64ada81c-39e1-49d9-959c-5c981569615d}">
      <Declaration><![CDATA[METHOD PROTECTED sta_RUN : BOOL
VAR
	ii: INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		udiPulseTimeoutTimer := 0;
		bolPulseFlag := FALSE;
		
		fbSimulationTimer.IN := FALSE;
		fbSimulationTimer.PT := UDINT_TO_TIME(SIf.Par.udi_pulseSim_ms);  
		fbSimulationTimer(); // set time/reset timer
		fbSimulationTimer.IN := TRUE; // start timer
			
		// Get Size of array
		intSpeedShiftSize := SIZEOF(aSpeedShift)/(SIZEOF(aSpeedShift[0]));
		// Clear speed buffer
		FOR ii:=0 TO intSpeedShiftSize-1 BY 1 DO
			aSpeedShift[ii]:=0;
		END_FOR
		
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// Simulation
		// AND speed simulation if no distance sensor is existing !!!
		IF ((CIf.SwCfg.bolSimulation) OR (SIf.Cfg.bolPulseExist = FALSE)) THEN
			fbSimulationTimer(); // simulation time
			IF (fbSimulationTimer.Q) THEN
				SIf.In.bolPulse.intern := TRUE; 
				In_bolPulse := TRUE; // MRU 22.10.2013 added for drive without pulse sensor
				fbSimulationTimer.IN := FALSE;
			ELSE
				SIf.In.bolPulse.intern := FALSE;
				In_bolPulse := FALSE; // MRU 22.10.2013 added for drive without pulse sensor
				fbSimulationTimer.IN := TRUE;
			END_IF
		END_IF
	
		IF SIf.Cfg.bolSpeedVariable = TRUE THEN
			SetSpeed();
		END_IF;
		
		udiPulseTimeoutTimer := udiPulseTimeoutTimer + me.FUBInfo.udiSample_ms;
		
		
		// Speed calculation
		IF udiTimerSpeedCalc >= cSpeedCalcTime_ms THEN
			dinSpeedNew_um_s := (SIf.Cur.dinPos_um - dinPosOld_um)*1000 / UDINT_TO_DINT(udiTimerSpeedCalc);
			dinSpeedCalc_um_s := dinSpeedNew_um_s;
			// Get Size of array
			intSpeedShiftSize := SIZEOF(aSpeedShift)/(SIZEOF(aSpeedShift[0]));
			intI := intSpeedShiftSize-1;
			WHILE intI > 0 DO		
				// Shift all speeds one field
				aSpeedShift[intI] := aSpeedShift[intI-1];
				dinSpeedCalc_um_s := dinSpeedCalc_um_s + aSpeedShift[intI];
				intI := intI - 1;
			END_WHILE
			aSpeedShift[0] := dinSpeedNew_um_s;
			SIf.Cur.dinSpeed_um_s := dinSpeedCalc_um_s / intSpeedShiftSize;
			dinPosOld_um := SIf.Cur.dinPos_um;
			udiTimerSpeedCalc := 0;
				
		ELSE
			udiTimerSpeedCalc := udiTimerSpeedCalc + me.FUBInfo.udiSample_ms;
		END_IF
		
		
		// State Change Condition
		IF ((udiPulseTimeoutTimer >= Sif.Par.udi_pulseTimeout_ms) AND (SIf.Cfg.bolPulseExist = TRUE)) THEN
			// SIf.Alm[2].strText := 'Timeout no pulse detected';
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,2,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);

			me.StateMachine.intStateNext :=  cSTA_ERROR;		
		ELSIF (me.intCmd=cCMD_OFF) THEN
			me.StateMachine.intStateNext :=  cSTA_OFFBusy;
		END_IF
		
	END_IF



//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		// Set speed zero
		SIf.Cur.dinSpeed_um_s := 0;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="StateMachine" Id="{76e61b69-2ddd-40e2-b9cb-c5f6c4d94c13}">
      <Declaration><![CDATA[METHOD PROTECTED StateMachine : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.StateMachine();

// main statemachine of base controller
CASE me.StateMachine.intState OF
    cSTA_RUNBusy: 
        THIS^.sta_RUNBusy();
    cSTA_RUN: 
        THIS^.sta_RUN();
END_CASE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetSpeed" Id="{82444629-d4d9-4f34-8182-4f77cf3ebf50}">
      <Declaration><![CDATA[METHOD PRIVATE SetSpeed
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// 0=slow, 1=middle, 2=fast
CASE SIf.Par.usi_speedLevel OF
	0:
		SIf.Out.bolSpeed_1.intern := TRUE;
		SIf.Out.bolSpeed_2.intern := FALSE;
	1:
		SIf.Out.bolSpeed_1.intern := TRUE;
		SIf.Out.bolSpeed_2.intern := TRUE;
	2:
		SIf.Out.bolSpeed_1.intern := FALSE;
		SIf.Out.bolSpeed_2.intern := TRUE;
	ELSE
		SIf.Out.bolSpeed_1.intern := TRUE;
		SIf.Out.bolSpeed_2.intern := FALSE;
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_RUNBusy" Id="{8c43ed54-7544-4f2a-ad61-b63a111170ba}">
      <Declaration><![CDATA[METHOD PROTECTED sta_RUNBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN

		IF SIf.Cfg.bolSpeedVariable = TRUE THEN
			SetSpeed();
		ELSE
			SIf.Out.bolSpeed_1.intern := TRUE;
		END_IF;		
		
		// State Change Condition
		IF (TRUE) THEN
			me.StateMachine.intStateNext := cSTA_RUN;
		END_IF
	END_IF




//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_PON" Id="{8f59ca7d-0709-4919-b0e8-04a2966a1c16}">
      <Declaration><![CDATA[METHOD PROTECTED sta_PON : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		;
		
		
		// State Change Condition
		IF ((me.intCmd=cCMD_OFF) OR (me.intCmd=cCMD_RUN)) THEN
			me.StateMachine.intStateNext := cSTA_OFFBusy;
		END_IF
	END_IF




//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="getCtrlSIf" Id="{91cfb138-4fec-4a9d-99a6-9fb2a422e959}">
      <Declaration><![CDATA[METHOD getCtrlSIf : POINTER TO T_Ctrl_SIf_DRV
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCtrlSIf := ADR(SIf);]]></ST>
      </Implementation>
    </Method>
    <Method Name="IoInBridge" Id="{fc3c7eba-9b32-487c-aa9b-d2850f15e2d3}">
      <Declaration><![CDATA[METHOD PROTECTED IoInBridge : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// digitale and analoge inputs read from hardware or forcing
SIf.In.bolOverload.map := THIS^.In_bolOverload;
SIf.In.bolPulse.map := THIS^.In_bolPulse;
SIf.In.bolMaintenanceSwitch.map := THIS^.In_bolMaintenanceSwitch;

FOR intI := 1 TO SIf.Cfg.usiCountBlockedSupervis DO
	SIf.In.a_bolBlockedSupvervis[intI].map := THIS^.In_a_bolBlockedSupvervis[intI];
	IF (CIf.SwCfg.bolSimulation = FALSE) THEN
		getInBol(CIf.Job.bolIoForce,ADR(SIf.In.a_bolBlockedSupvervis[intI]));
	END_IF
END_FOR

IF (CIf.SwCfg.bolSimulation = FALSE) THEN
	getInBol(CIf.Job.bolIoForce,ADR(SIf.In.bolOverload));
	getInBol(CIf.Job.bolIoForce,ADR(SIf.In.bolPulse));
	//ctrl.In.bol_PosSwitchBasicDefTyp.intern := getInBol(ctrl.ifc.Job.bol_Force ,ADR(ctrl.In.bol_PosSwitchBasicDefTyp);
	getInBol(CIf.Job.bolIoForce,ADR(SIf.In.bolMaintenanceSwitch));
ELSE
	//simulation of global IO
	SIf.In.bolOverload.intern := FALSE;
	SIf.In.bolMaintenanceSwitch.intern := FALSE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <ObjectProperties />
  </POU>
</TcPlcObject>