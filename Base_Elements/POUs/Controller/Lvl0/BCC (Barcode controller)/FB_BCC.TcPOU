<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.0.25">
  <POU Name="FB_BCC" Id="{fbf2011b-2107-46f8-95d3-825b753a2c4c}">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_BCC EXTENDS FB_CtrlBase
VAR_INPUT
	In_bolSensorTrigScan AT %I* : BOOL;
	pBCD_SIf_In: POINTER TO T_BCD;
END_VAR
VAR
	/// Specific interface struct for public access
	SIf: T_Ctrl_SIf_BCC;
	/// old barcode to know that a new barcode is present from sensor
	uliBarCodeOld: ULINT;
	/// simulated barcode
	uliSimBarCode: ULINT;
	/// Variables for driver simulation
	pBCD_SIf: POINTER TO T_BCD;
	stBCD_Sim: T_BCD;
	/// Edge detection of trigger sensor 
	bolSensorTrigScanOld : BOOL;
	/// Exceute scan flag
	bolExecuteScan : BOOL;
	udiScanDelayTimer_ms: UDINT;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*__________________________________________________________________________________________________
¦	
¦	Vistaprint Schweiz GmbH
¦	CH - 8401 Winterthur
¦
¦	www.vistaprint.ch - info@vistaprint.ch
¦___________________________________________________________________________________________________

Function desription:
Barcode reader controller.
Controls the communication to the barcode reader.

History:
Version		Date			Author		Comment
---------------------------------------------------------------------------------------------------
0.00.1		06.01.2014		AVME/DSC	Start history
0.00.2		07.01.2014		AVME/DSC	Basic functionalities implemented and tested. 	
0.00.3		27.01.2014		AVME/DSC	- Added info "bolNoRead" in cur interface
					 					- Revision in error recovery
0.00.4		15.07.2014		AVME/DSC   RP-208 - Implement sensor signal input for triggering a barcode scan
									   The controller is already implemented with a common interface waiting for command READ to execute a new barcode scan.
									   Controller is now equipped with a further option to execute a scan by checking a sensor signal input.
0.00.5		24.10.2014		HLV/MAH		driver can be used for Sick or Keyence scanner configured by SIf.Cfg.iSensorType := E_BCD_Type.xxxx
										the port of Keyence scanner must be always 9004
										if Keyence scanner is used, FB_SocketCloseAll must be called in main PRG (see MiddlePRG in BaseElementsSample)

___________________________________________________________________________________________________*)

SUPER^();

(*
IF (me.bolActivate) AND (pBCD_SIf_In<>0) THEN // cyclic call enabled
	IF (CIf.Info.bolInitDone=FALSE) THEN // first cycle -> init
		CtrlInit();
		CIf.Info.bolInitDone := TRUE;
	ELSE
		CycleStartDuty();
	
		Always();
		
		StateMachine();
		
		CycleEndDuty();
	
	END_IF
END_IF;
*)]]></ST>
    </Implementation>
    <Method Name="sta_PON" Id="{01cc933b-8c68-4cb8-aec7-bfb623a35860}">
      <Declaration><![CDATA[METHOD PROTECTED sta_PON : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		;	
		// State Change Condition
		me.StateMachine.intStateNext := cSTA_OFFBusy;
	END_IF


//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="IoOutBridge" Id="{131f17d4-1d38-45bd-bd10-a26d9de9d2b0}">
      <Declaration><![CDATA[METHOD PROTECTED IoOutBridge : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// digitale and analoge inputs read from hardware or forcing
IF (CIf.SwCfg.bolSimulation = FALSE) THEN
	// check interlocks to prevent damages
	IF (CIf.Job.bolIlkOverwrite=FALSE) THEN
		;
		// no physical outputs
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_READ" Id="{36c8fc0a-3ea9-4f0b-a5b4-62457d77f269}">
      <Declaration><![CDATA[METHOD PROTECTED sta_READ : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;

	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN

		// Simulation
		IF (CIf.SwCfg.bolSimulation) THEN
			;
		END_IF
		
		// State Change Condition
		IF(me.intCmd=cBCC_CMD_READ) THEN
			me.StateMachine.intStateNext := cBCC_STA_READBusy;
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="IoInBridge" Id="{736ac810-e763-43ba-8c62-602b2d2c91a2}">
      <Declaration><![CDATA[METHOD PROTECTED IoInBridge : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// digitale and analoge inputs read from hardware or forcing
SIf.In.bolSensorTrigScan.map := THIS^.In_bolSensorTrigScan;

IF (CIf.SwCfg.bolSimulation = FALSE) THEN
	getInBol(CIf.Job.bolIoForce,ADR(SIf.In.bolSensorTrigScan));
ELSE
	//simulation of global IO
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="getCmdState" Id="{7d061af7-1d53-4e3a-8aeb-4a55c47e1b35}">
      <Declaration><![CDATA[METHOD PROTECTED getCmdState : STRING
VAR_INPUT
	intCmdState: INT;
	bolState: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCmdState := SUPER^.getCmdState(intCmdState:=intCmdState,bolState:=bolState); // get global/base defined cmds/states
IF (getCmdState='') THEN // global not defined get local
	// get string cmd/state string information in runtime
	IF (bolState=FALSE) THEN
		// cmd's
		CASE intCmdState OF
			cBCC_CMD_READ: 
				getCmdState := 'cBCC_CMD_READ';
		END_CASE;
	ELSE
	
	// cmd's
		CASE intCmdState OF
			cBCC_STA_READBusy: 
				getCmdState := 'cBCC_STA_READBusy';
			cBCC_STA_READ: 
				getCmdState := 'cBCC_STA_READ';
		END_CASE;
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="StateMachine" Id="{8cff909d-cc34-46e0-bde9-47c56909eb09}">
      <Declaration><![CDATA[METHOD PROTECTED StateMachine : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.StateMachine();

// main statemachine of base controller
CASE me.StateMachine.intState OF
    cBCC_STA_READBusy: 
        THIS^.sta_READBusy();
    cBCC_STA_READ: 
        THIS^.sta_READ();	
END_CASE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_OFFBusy" Id="{931f5406-1eb9-4d7a-a3e4-83db51e691b1}">
      <Declaration><![CDATA[METHOD PROTECTED sta_OFFBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		// Simulation timer	
		fbSimulationTimer.IN := FALSE;
		fbSimulationTimer.PT := UDINT_TO_TIME(SIf.Par.udiTORead_ms / 2);
		fbSimulationTimer(); // set time/reset timer
		fbSimulationTimer.IN := TRUE; // start timer
		
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// Simulation
		IF (CIf.SwCfg.bolSimulation) THEN
			fbSimulationTimer(); // simulation time
			IF (fbSimulationTimer.Q) THEN
				pBCD_SIf^.intCmd := cBCD_CMD_DONE;
			END_IF
		END_IF
			
		// State Change Condition
		IF (pBCD_SIf^.stErr.bolErrorActive = TRUE) THEN
			me.StateMachine.intStateNext :=  cSTA_ERROR;
		ELSIF(pBCD_SIf^.intCmd = cBCD_CMD_DONE) THEN
			me.StateMachine.intStateNext := cSTA_OFF;
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_PONBusy" Id="{9ba61e63-c0f8-41bc-940e-d4021383955e}">
      <Declaration><![CDATA[METHOD PROTECTED sta_PONBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		// Simulation timer	
		fbSimulationTimer.IN := FALSE;
		fbSimulationTimer.PT := UDINT_TO_TIME(SIf.Par.udiTORead_ms / 2);
		fbSimulationTimer(); // set time/reset timer
		fbSimulationTimer.IN := TRUE; // start timer
		
		// Reset driver status
		pBCD_SIf^.stStatus.bolSocketConnected := FALSE;
		pBCD_SIf^.stStatus.bolComChecked := FALSE;
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
			
		// Simulation
		IF (CIf.SwCfg.bolSimulation) THEN
			fbSimulationTimer(); // simulation time
			IF (fbSimulationTimer.Q) THEN
				// Set driver status
				pBCD_SIf^.stStatus.bolSocketConnected := TRUE;
				pBCD_SIf^.stStatus.bolComChecked := TRUE;		
			END_IF
		END_IF
			
		// Try to open the TCP socket
		IF (pBCD_SIf^.stStatus.bolSocketConnected = FALSE) THEN		
			pBCD_SIf^.intCmd := cBCD_CMD_CONNECT_SOCKET; 
		END_IF 
					
		// Check if socket connected
		IF (pBCD_SIf^.stStatus.bolSocketConnected = TRUE) AND (pBCD_SIf^.stStatus.bolComChecked = FALSE) THEN
			pBCD_SIf^.intCmd :=	cBCD_CMD_COM_TEST; // Execute a communication test to see if the device answer		
		END_IF
		
		// State Change Condition
		IF ((pBCD_SIf^.stErr.bolErrorActive = TRUE) OR (me.StateMachine.udiTimeInState_ms >= SIf.Par.udiTOPowerOn_ms)) THEN
			// SIf.Alm[2].strText := 'Initialisation error from barcode reader. No answer from device.';
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,2,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := cSTA_ERROR;				
		ELSIF (pBCD_SIf^.stStatus.bolComChecked = TRUE) THEN
			me.StateMachine.intStateNext := cSTA_PON;
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_READBusy" Id="{a12e8bac-99cf-4883-87ce-a1d8ad621c07}">
      <Declaration><![CDATA[METHOD PROTECTED sta_READBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		// Simulation timer	
		fbSimulationTimer.IN := FALSE;
		fbSimulationTimer.PT := UDINT_TO_TIME(SIf.Par.udiTORead_ms / 2);
		fbSimulationTimer(); // set time/reset timer
		fbSimulationTimer.IN := TRUE; // start timer
		
		// Init
		SIf.Cur.bolNewCodeReaded:= FALSE;
		SIf.Cur.bolNoRead:= FALSE;
		SIf.Cur.stData.uliBarCode:= 0;
		SIf.Cur.stData.strBarCode:= '';
		
		// Read barcode
		pBCD_SIf^.intCmd := cBCD_CMD_READ_BARCODE;
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN

		// Simulation
		IF (CIf.SwCfg.bolSimulation) THEN
			fbSimulationTimer(); // simulation time
			IF (fbSimulationTimer.Q) THEN
				SIf.Cur.bolNewCodeReaded:= TRUE;
				uliSimBarCode:= uliSimBarCode + 1;
				pBCD_SIf^.stData.uliBarCode:= uliSimBarCode;
				pBCD_SIf^.stData.strBarCode:= ULINT_TO_STRING(pBCD_SIf^.stData.uliBarCode);
				pBCD_SIf^.intCmd := cBCD_CMD_DONE;		
			END_IF
		END_IF	

		// Check for new barcode
		IF (pBCD_SIf^.stData.uliBarCode <> uliBarCodeOld) AND (pBCD_SIf^.stData.uliBarCode<>0) THEN
			uliBarCodeOld:= pBCD_SIf^.stData.uliBarCode;
			SIf.Cur.bolNewCodeReaded:= TRUE;
		END_IF
		
		// Get data from driver
		SIf.Cur.stData.uliBarCode:= pBCD_SIf^.stData.uliBarCode;
		SIf.Cur.stData.strBarCode:= pBCD_SIf^.stData.strBarCode;			
		
		// State Change Condition
		IF (pBCD_SIf^.stErr.bolErrorActive = TRUE) THEN  
			me.StateMachine.intStateNext :=  cSTA_ERROR;
		ELSIF (me.StateMachine.udiTimeInState_ms > SIf.Par.udiTORead_ms) THEN
			// SIf.Alm[4].strText := 'Timeout wait on data';
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,4,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext :=  cSTA_ERROR;
		ELSIF (pBCD_SIf^.intCmd = cBCD_CMD_DONE) THEN
			IF (SIf.Cur.stData.uliBarCode=0) THEN
				SIf.Cur.bolNoRead:= TRUE;
				uliBarCodeOld:= 0;
				// SIf.Alm[3].strText := 'Barcode could not be read. Answer *NoRead* from device';
				pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,3,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);	
			END_IF		
			me.StateMachine.intStateNext := cBCC_STA_READ;
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		CIf.Job.intACmd:= cCMD_DONE;
		CIf.Job.intMCmd:= cCMD_DONE;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_ERROR" Id="{cafc0f0b-7fbf-4570-868e-98e4aa90d1dd}">
      <Declaration><![CDATA[METHOD PROTECTED sta_ERROR : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateHistory := me.StateMachine.intStateLastCycle; // -> possibillity to go back to state before error
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		// Driver error activ
		IF (pBCD_SIf^.stErr.bolErrorActive = TRUE) THEN
			// SIf.Alm[1].strText := 'Barcode reader driver error'; 
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,1,UDINT_TO_DINT(pBCD_SIf^.stErr.udiErrorID),ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			// Error response from sensor
			IF (pBCD_SIf^.stErr.bolSensorError = TRUE) THEN
				// SIf.Alm[5].strText := 'Error response from sensor with sopas error number';
				pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,5,UDINT_TO_DINT(pBCD_SIf^.stErr.udiErrorID),ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);		
			END_IF
		ELSE
			// Close TCP socket		
			pBCD_SIf^.intCmd := cBCD_CMD_CLOSE_SOCKET;  	
		END_IF
		
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
	
		// State Change Condition
		IF (CIf.Job.bolAlmReset = TRUE) THEN
			// Error ack driver 
			pBCD_SIf^.stErr.bolErrAck:= TRUE;
			me.StateMachine.intStateNext := cSTA_ERRORQuit;
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_OFF" Id="{cd8d8693-b298-4093-a80f-8ad5f4a27007}">
      <Declaration><![CDATA[METHOD PROTECTED sta_OFF : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		;		
		// State Change Condition
		IF (me.Alarm.eActivAlmClass<>E_AlmClass.EOFF) AND (me.Alarm.eActivAlmClass<>E_AlmClass.OFF) THEN	
			IF(me.intCmd=cBCC_CMD_READ) THEN
				me.StateMachine.intStateNext := cBCC_STA_READBusy;
			END_IF
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Always" Id="{d611dada-56f3-4176-9250-865885382e06}">
      <Declaration><![CDATA[METHOD PROTECTED Always : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.Always();

// Simulation
IF (CIf.SwCfg.bolSimulation) THEN
	// Access to driver empty structure
	pBCD_SIf := ADR(stBCD_Sim);
ELSE
	// Access to real driver interface
	pBCD_SIf := pBCD_SIf_In;
END_IF

// ----------------------------------------------------------------------------------
// cyclic actions outside of statemachine
IF (me.StateMachine.intState<>cSTA_SINGLE_ANSWER) THEN
	
	// Handle sensor trigger input
	// --------------------------------------------
	// Check pos. edge of the sensor 
	IF (SIf.In.bolSensorTrigScan.intern) AND NOT (bolSensorTrigScanOld) THEN	
		// Kick-off a new scan
		bolExecuteScan:= TRUE;
	END_IF

	// Execute scan?
	IF (bolExecuteScan) AND (me.StateMachine.intState<>BCC_CmdState.cBCC_STA_READBusy) THEN
		// Wait X-time (time delay) before executing a barcode scan 
		IF (udiScanDelayTimer_ms >= SIf.Par.udiExecuteScanDelayTime_ms) THEN
			bolExecuteScan:= FALSE;
			me.StateMachine.intStateNext := BCC_CmdState.cBCC_STA_READBusy;
		END_IF
		// Timer handling
		udiScanDelayTimer_ms:= udiScanDelayTimer_ms + me.FUBInfo.udiSample_ms;
	ELSE
		// Reset timer
		udiScanDelayTimer_ms:= 0;
	END_IF
	
	// Check trigger error conditions
	// --------------------------------------------
	// In case if a new scan will be triggered by the sensor trigger input but a scan is already in progress -> set warning!
	// Check if Scan in progress
	IF (me.StateMachine.intState=BCC_CmdState.cBCC_STA_READBusy) THEN
		// New pos. trigger signal detected during scan
		IF (SIf.In.bolSensorTrigScan.intern) AND (bolSensorTrigScanOld <> SIf.In.bolSensorTrigScan.intern) THEN
			// SIf.Alm[6].strText := 'New scan was triggered during a scan was already in progress. Check line speed and barcode reader settings!';
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,6,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);	
		END_IF
	END_IF
	
	// Save sensor signal. Used for edge detection
	bolSensorTrigScanOld:= SIf.In.bolSensorTrigScan.intern;
		
	// Status info from driver
	// --------------------------------------------
	SIf.Cur.bolComChecked:= pBCD_SIf^.stStatus.bolComChecked;
	SIf.Cur.bolConnected:= pBCD_SIf^.stStatus.bolSocketConnected;
	
END_IF

// config driver
pBCD_SIf^.stCfg.bolSimulation := CIf.SwCfg.bolSimulation;
pBCD_SIf^.stCfg.strSensorIPAdr := SIf.Cfg.strSensorIPAdr;
pBCD_SIf^.stCfg.udiSensorPort := SIf.Cfg.udiSensorPort;
pBCD_SIf^.stCfg.iSensorType := SIf.Cfg.iSensorType;

// ----------------------------------------------------------------------------------
// Always change actions in Base Library
// ----------------------------------------------------------------------------------
// overrule error always from base -> no EOFF State!! in EOFF go to OFF
IF (me.StateMachine.intStateNext = cSTA_EOFFBusy) THEN
	IF (me.StateMachine.intState=cSTA_OFF) THEN
		me.StateMachine.intStateNext := cSTA_OFF;
	ELSE // stay in OFF
		me.StateMachine.intStateNext := cSTA_OFFBusy;
	END_IF
END_IF

// Conditions Always
IF (((me.Alarm.eActivAlmClass=E_AlmClass.EOFF) OR (me.Alarm.eActivAlmClass=E_AlmClass.OFF) OR (me.intCmd=cCMD_OFF))
		 AND (me.StateMachine.intState<>cSTA_ERROR) AND (me.StateMachine.intState<>cSTA_ERRORQuit) AND
		(me.StateMachine.intState<>cSTA_OFF) AND (me.StateMachine.intState<>cSTA_OFFBusy)) THEN
	// alarm evt EOFF, OFF or cmd off
	me.StateMachine.intStateNext := cSTA_OFFBusy;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{dad5b1cb-0c8a-4234-bcc2-fd3a14b25d0a}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	///if TRUE, the retain variables are initialized (warm start / cold start)
	bInitRetains: BOOL;
	///if TRUE, the instance afterwards gets moved into the copy code (online change)
	bInCopyCode: BOOL;
END_VAR
VAR
	udiTaskCnt: UDINT;
	ii: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//------------------------------------------------------------------------------------------------------------------------
// to manually change in new FUB implementation!!!
// define valid commands for this controller
FOR ii:= 0 TO (SIZEOF(CIf.Job.aCmdList)/SIZEOF(CIf.Job.aCmdList[0])-1) BY 1 DO
	IF (CIf.Job.aCmdList[ii].intCmd=cCMD_INITIALIZED) THEN
		// found first empty array element
		EXIT;
	END_IF
END_FOR
CIf.Job.aCmdList[ii].intCmd := cBCC_CMD_READ;
CIf.Job.aCmdList[ii].strName := 'Read'; 
CIf.Job.aCmdList[ii].bolAvailable := TRUE;

// set name of class/typ
CIf.Info.strType := 'FB_BCC'; 

// set alarm class
SIf.Alm[1].eAlmClass := E_AlmClass.INFO;
SIf.Alm[1].strText := 'Barcode reader driver error'; 
SIf.Alm[2].eAlmClass := E_AlmClass.OFF;
SIf.Alm[2].strText := 'Initialisation error from barcode reader. No answer from device.';
SIf.Alm[3].eAlmClass := E_AlmClass.INFO;
SIf.Alm[3].strText := 'Barcode could not be read. Answer *NoRead* from device';
SIf.Alm[4].eAlmClass := E_AlmClass.INFO;
SIf.Alm[4].strText := 'Timeout wait on data';
SIf.Alm[5].eAlmClass := E_AlmClass.INFO;
SIf.Alm[5].strText := 'Error response from sensor';
SIf.Alm[6].eAlmClass := E_AlmClass.WARNING;
SIf.Alm[6].strText := 'New scan was triggered during a scan was already in progress!';

//*******************************************************************************
// initial values
//*******************************************************************************

// software configuration
CIf.SwCfg.bolExist := TRUE;
CIf.SwCfg.bolSimulation := FALSE;

// parameter
SIf.Par.udiTORead_ms := 4000;  		// Has to be correspond with the "duration" setting of sensor object trigger
SIf.Par.udiTOPowerOn_ms := 3000;
SIf.Par.udiExecuteScanDelayTime_ms:= 500;

// configuration
SIf.Cfg.strSensorIPAdr := '192.168.1.103';
SIf.Cfg.udiSensorPort := 9004;
SIf.Cfg.iSensorType := E_BCD_Type.KEYENCE;

// simulation
uliSimBarCode:= 1250000000000;]]></ST>
      </Implementation>
    </Method>
    <Method Name="getCtrlSIf" Id="{f7a6c6fd-fcfe-43ea-ac08-cec1b97fc44e}">
      <Declaration><![CDATA[METHOD getCtrlSIf : POINTER TO T_Ctrl_SIf_BCC
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCtrlSIf := ADR(SIf);]]></ST>
      </Implementation>
    </Method>
    <ObjectProperties />
  </POU>
</TcPlcObject>